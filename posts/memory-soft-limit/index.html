<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Memory Soft limits | Lebedev Aleksandr</title>
<meta name=keywords content="memory,cgroup,linux,docker"><meta name=description content="Изучая возможности контрольных групп в linux наткнулся на параметр memory.soft_limit_in_bytes:
When the system detects memory contention or low memory, control groups are pushed back to their soft limits. If the soft limit of each control group is very high, they are pushed back as much as possible to make sure that one control group does not starve the others of memory.
Аналог в cgroup2 - memory.low
Звучит интересно! Сделаем несколько тестов для понимания как это все работает."><meta name=author content><link rel=canonical href=https://alebsys.github.io/posts/memory-soft-limit/><meta name=google-site-verification content="XYZabc"><meta name=yandex-verification content="XYZabc"><meta name=msvalidate.01 content="XYZabc"><link crossorigin=anonymous href=/assets/css/stylesheet.a34d62e564cfbcf98a7cbba67f377fd3d6fced4d48b2155a08723ae31c875712.css integrity="sha256-o01i5WTPvPmKfLumfzd/09b87U1IshVaCHI64xyHVxI=" rel="preload stylesheet" as=style><link rel=icon href=https://alebsys.github.io/%3Clink%20/%20abs%20url%3E><link rel=icon type=image/png sizes=16x16 href=https://alebsys.github.io/%3Clink%20/%20abs%20url%3E><link rel=icon type=image/png sizes=32x32 href=https://alebsys.github.io/%3Clink%20/%20abs%20url%3E><link rel=apple-touch-icon href=https://alebsys.github.io/%3Clink%20/%20abs%20url%3E><link rel=mask-icon href=https://alebsys.github.io/%3Clink%20/%20abs%20url%3E><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://alebsys.github.io/posts/memory-soft-limit/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script async src="https://www.googletagmanager.com/gtag/js?id=G-VDR541GTVE"></script><script>var doNotTrack=!1;if(!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-VDR541GTVE",{anonymize_ip:!1})}</script><meta property="og:title" content="Memory Soft limits"><meta property="og:description" content="Изучая возможности контрольных групп в linux наткнулся на параметр memory.soft_limit_in_bytes:
When the system detects memory contention or low memory, control groups are pushed back to their soft limits. If the soft limit of each control group is very high, they are pushed back as much as possible to make sure that one control group does not starve the others of memory.
Аналог в cgroup2 - memory.low
Звучит интересно! Сделаем несколько тестов для понимания как это все работает."><meta property="og:type" content="article"><meta property="og:url" content="https://alebsys.github.io/posts/memory-soft-limit/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2024-06-16T00:00:00+00:00"><meta property="article:modified_time" content="2024-06-16T00:00:00+00:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="Memory Soft limits"><meta name=twitter:description content="Изучая возможности контрольных групп в linux наткнулся на параметр memory.soft_limit_in_bytes:
When the system detects memory contention or low memory, control groups are pushed back to their soft limits. If the soft limit of each control group is very high, they are pushed back as much as possible to make sure that one control group does not starve the others of memory.
Аналог в cgroup2 - memory.low
Звучит интересно! Сделаем несколько тестов для понимания как это все работает."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://alebsys.github.io/posts/"},{"@type":"ListItem","position":2,"name":"Memory Soft limits","item":"https://alebsys.github.io/posts/memory-soft-limit/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Memory Soft limits","name":"Memory Soft limits","description":"Изучая возможности контрольных групп в linux наткнулся на параметр memory.soft_limit_in_bytes:\nWhen the system detects memory contention or low memory, control groups are pushed back to their soft limits. If the soft limit of each control group is very high, they are pushed back as much as possible to make sure that one control group does not starve the others of memory.\nАналог в cgroup2 - memory.low\nЗвучит интересно! Сделаем несколько тестов для понимания как это все работает.","keywords":["memory","cgroup","linux","docker"],"articleBody":"Изучая возможности контрольных групп в linux наткнулся на параметр memory.soft_limit_in_bytes:\nWhen the system detects memory contention or low memory, control groups are pushed back to their soft limits. If the soft limit of each control group is very high, they are pushed back as much as possible to make sure that one control group does not starve the others of memory.\nАналог в cgroup2 - memory.low\nЗвучит интересно! Сделаем несколько тестов для понимания как это все работает.\nНемного проблематики Ресурсная модель в kubernetes основана на requests/limits к CPU и memory - абстракции над параметрыми cgroups.\nПричем CPU requests (cpu.shares) используются более разносторонне:\nпри планировании Пода kube-scheduler’ом; для обеспечения “гарантированной” доли CPU на машине. Ранее писал про это применительно к специфике JVM.\nА вот механизмы вокруг memory таким похвастать не могут - реквесты используются только для выбора подходящей ноды.\nС другой стороны docker умеет работать с soft limits через флаг --memory-reservation, что расширяет потенциальную область применимости.\nК тестам Дано:\nвиртуальная машина с debian 11 и 8Gb RAM; docker v20.10.17; набор контейнеров, алоцирующие по 1Gb анонимной памяти каждый. Для воспроизведения код аллокации:\nimport numpy as np def allocate_memory(size_in_gb): size_in_bytes = size_in_gb * 1024**3 num_elements = size_in_bytes // np.dtype('float64').itemsize memory_block = np.zeros(num_elements, dtype='float64') for i in range(num_elements): memory_block[i] = i % 256 while True: pass if __name__ == \"__main__\": allocate_memory(1) и Dockerfile:\nFROM python:3.9-slim WORKDIR /app RUN pip install numpy COPY allocate_memory.py . CMD [\"python\", \"allocate_memory.py\"] Зафиксируем объем свободной памяти:\n# free -h total used free shared buff/cache available Mem: 7,8Gi 656Mi 6,8Gi 79Mi 339Mi 6,8Gi Swap: 0B 0B 0B И начнем запускаться в разных конфигурациях.\n1. Семь контейнеров без софт лимитов # for i in {1..7}; do docker run --rm -d mem-anon-1gb; done 74a5212e5061d3f4f5cf71af116fc4b151997c58f76e453a16260354106b2ba0 a0cdf9b5c7d43c894b2820cf66a22e5e412781cfda670ca4727dac75a82f1d07 eb2367e472efbce609f4859acbebc82b97830765765a240dcaef8509ec4c5712 4288b784bcd239b3c11deaa71886adf5c59792edaffaadcad23a9b7335c2b24d 8ed56c614be71159f9e64347cfb601e18092e3c65bd1e069beed13c11bb59f34 aa1425bae3f5652d0f38b0658d384adb22de6334a55b604ac69940755854ce4e 79ebce488f401397e52a1171dd3b5652d2b11a52d9e4b000d53038bdf6b78053 # free -h total used free shared buff/cache available Mem: 7,8Gi 7,5Gi 124Mi 79Mi 150Mi 23Mi Swap: 0B 0B 0B # docker stats --no-stream --format \"{{.Container}}: {{.MemUsage}}\" 74a5212e5061: 628.3MiB / 7.791GiB a0cdf9b5c7d4: 1.019GiB / 7.791GiB eb2367e472ef: 1.022GiB / 7.791GiB 4288b784bcd2: 1.018GiB / 7.791GiB 8ed56c614be7: 1.022GiB / 7.791GiB aa1425bae3f5: 1.024GiB / 7.791GiB 79ebce488f40: 1.026GiB / 7.791GiB ### прошло несколько минут... # docker ps -a ... a0cdf9b5c7d4 ... Exited (137) 55 seconds ago ... ... При запуске седьмого контейнера иссякла память и docker отправил SIGKILL в рандомный контейнер для ее высвобождения:\n# free -h total used free shared buff/cache available Mem: 7,8Gi 6,8Gi 604Mi 79Mi 454Mi 726Mi Swap: 0B 0B 0B # docker stats --no-stream --format \"{{.Container}}: {{.MemUsage}}\" 74a5212e5061: 1.019GiB / 7.791GiB eb2367e472ef: 1.018GiB / 7.791GiB 4288b784bcd2: 1.022GiB / 7.791GiB 8ed56c614be7: 1.024GiB / 7.791GiB aa1425bae3f5: 1.026GiB / 7.791GiB 79ebce488f40: 1.022GiB / 7.791GiB 2. Семь контейнеров без софт лимитов + swap в 2Gb Создадим swap раздел: sudo fallocate -l 2G /swapfile sudo chmod 600 /swapfile sudo mkswap /swapfile sudo swapon /swapfile Запустим первые шесть контейнеров: # for i in {1..6}; do docker run --rm -d mem-anon-1gb; done 81511a32dc43b8f26610d4ed34891a846bb730b1e64bfb4bf269d388b6910f39 caf7ce67ae058a0979f1ddf81062efd708807e958167ea93fdc1bc2f236c69ee f7976d6d00c9530936f37702aae24f130e83c70441f98c7804d33b146adc9fd2 696f0950addd7c838ca20fa6a89ed8c4f55ee1043a903d729db140dc997f0fb1 82aa3421260f22f0a94acb3f74aea201e4dc0c7c2f1fd6fb29449e66b26e7a15 e83b17188939bc27693416abeef368ebc301516f27cf54a070e1ba0a0728eafa # free -h total used free shared buff/cache available Mem: 7,8Gi 6,8Gi 653Mi 31Mi 377Mi 746Mi Swap: 2,0Gi 0Gi 2,0Gi # docker stats --no-stream --format \"{{.Container}}: {{.MemUsage}}\" e83b17188939: 1.022GiB / 7.791GiB 82aa3421260f: 1.024GiB / 7.791GiB 696f0950addd: 1.026GiB / 7.791GiB f7976d6d00c9: 1.026GiB / 7.791GiB caf7ce67ae05: 1.03GiB / 7.791GiB 81511a32dc43: 1.033GiB / 7.791GiB Все контейнеры помещаются в оперативной памяти.\nДобавим седьмой: # docker run --rm -d mem-anon-1gb f4451acbedcabd9f725dcdeae6c0982550dbac66ebd2c2f6501f951b6a4a9204 # docker stats --no-stream --format \"{{.Container}}: {{.MemUsage}}\" f4451acbedca: 1.016GiB / 7.791GiB e83b17188939: 1013MiB / 7.791GiB 82aa3421260f: 1003MiB / 7.791GiB 696f0950addd: 986MiB / 7.791GiB f7976d6d00c9: 965.6MiB / 7.791GiB caf7ce67ae05: 947.8MiB / 7.791GiB 81511a32dc43: 1.028GiB / 7.791GiB # free -h total used free shared buff/cache available Mem: 7,8Gi 7,4Gi 141Mi 19Mi 259Mi 127Mi Swap: 2,0Gi 513Mi 1,5Gi Как только память опустилась до минимально разрешенного уровня начался процесс свопинга, что унесло часть анонимной памяти рандомных контейнеров в swap.\n3. Шесть контейнеров без софт лимитов + один с софт лимитом в 0.5Gb + swap в 2Gb Запустим конейтенер с софт лимитами: # docker run --rm -d --memory-reservation=\"0.5g\" mem-anon-1gb 601e16e8ad6fca2990242c8b7b2617a8d042c9eef27ad4d15b5a7ad30c823f4d # docker stats --no-stream --format \"{{.Container}}: {{.MemUsage}}\" 601e16e8ad6f: 1.03GiB / 7.791GiB # free -h total used free shared buff/cache available Mem: 7,8Gi 1,6Gi 5,8Gi 28Mi 366Mi 5,9Gi Swap: 2,0Gi 0Gi 2,0Gi Контейнер полностью поместился в RAM.\nДобавим остальные шесть без лимитов: # for i in {1..6}; do docker run --rm -d mem-anon-1gb; done a25f97d7b5954542a4f1fe5227adefecc31e2c4f0c3fec30bc5c238c03e37122 571e76046aaf0af4e9ebca68b7e2da07d9468cc3ab0d473693a65ee6338dd621 7c152c4d7973b6d8e16618d7a673022a1b388dbd66767905af2566df26fffd3e 02c7d1be0ab2633623a8cd604b48d9f2e047954ed7feeda2289cfb6e253e17e6 948a95bd17ab294af18b899cbc1f6177a41b0ad540825020dbc978b6efc50f60 18ca4b465ee5229ee837bb5b22916e37009aa7ab56d341221873719df730a26c # free -h total used free shared buff/cache available Mem: 7,8Gi 7,3Gi 141Mi 29Mi 372Mi 230Mi Swap: 2,0Gi 558Mi 1,5Gi # docker stats --no-stream --format \"{{.Container}}: {{.MemUsage}}\" 18ca4b465ee5: 1.018GiB / 7.791GiB 948a95bd17ab: 1.018GiB / 7.791GiB 02c7d1be0ab2: 1.018GiB / 7.791GiB 7c152c4d7973: 1.018GiB / 7.791GiB 571e76046aaf: 1.018GiB / 7.791GiB a25f97d7b595: 1.018GiB / 7.791GiB 601e16e8ad6f: 610.4MiB / 7.791GiB Все как завещали в документации - контейнер с софт лимитами (601e16e8ad6f) “стротлился” в swap. Работает!\nВыводы Софт лимиты интересный функционал способный мягко ограничивать потребление памяти при ее нехватки в системе, что добавляет гибкости при выстраивания различных уровней QoS.\nМожно сказать, что это аналог механизма троттлинга CPU.\nИз особенностей:\nсофт лимиты не гарантируют высвобождения памяти (best-effort), но стараться будут; не используются в kubernetes (но есть в docker); для вытестенения анонимной памяти потребуется swap раздел; для вытеснения file-backed памяти ничего дополнительно не потребуется - данные будут перетекать из page cache на диск; стоит не забывать о пенальти на производительность при работе с дисками. Будет здорово узнать ваши кейсы: кто, как и зачем использует софт лимиты в своих системах! Велкам в комменты.\nУдачи!\n","wordCount":"883","inLanguage":"en","datePublished":"2024-06-16T00:00:00Z","dateModified":"2024-06-16T00:00:00Z","mainEntityOfPage":{"@type":"WebPage","@id":"https://alebsys.github.io/posts/memory-soft-limit/"},"publisher":{"@type":"Organization","name":"Lebedev Aleksandr","logo":{"@type":"ImageObject","url":"https://alebsys.github.io/%3Clink%20/%20abs%20url%3E"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://alebsys.github.io/ accesskey=h title="Lebedev Aleksandr (Alt + H)"><img src=https://alebsys.github.io/apple-touch-icon.png alt aria-label=logo height=35>Lebedev Aleksandr</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://alebsys.github.io/>Home</a>&nbsp;»&nbsp;<a href=https://alebsys.github.io/posts/>Posts</a></div><h1 class="post-title entry-hint-parent">Memory Soft limits</h1><div class=post-meta><span title='2024-06-16 00:00:00 +0000 UTC'>June 16, 2024</span>&nbsp;·&nbsp;5 min</div></header><div class=post-content><p>Изучая возможности контрольных групп в linux наткнулся на параметр <a href=https://docs.kernel.org/admin-guide/cgroup-v1/memory.html#soft-limits>memory.soft_limit_in_bytes</a>:</p><blockquote><p>When the system detects memory contention or low memory, control groups are pushed back to their soft limits. If the soft limit of each control group is very high, they are pushed back as much as possible to make sure that one control group does not starve the others of memory.</p></blockquote><p>Аналог в cgroup2 - <a href=https://facebookmicrosites.github.io/cgroup2/docs/memory-controller.html><code>memory.low</code></a></p><p>Звучит интересно! Сделаем несколько тестов для понимания как это все работает.</p><h3 id=немного-проблематики>Немного проблематики<a hidden class=anchor aria-hidden=true href=#немного-проблематики>#</a></h3><p>Ресурсная модель в <strong>kubernetes</strong> основана на requests/limits к CPU и memory - абстракции над параметрыми cgroups.</p><p>Причем CPU requests (<a href=https://gist.github.com/mcastelino/b8ce9a70b00ee56036dadd70ded53e9f#cgroups-and-cpu-constraints>cpu.shares</a>) используются более разносторонне:</p><ul><li>при планировании Пода kube-scheduler&rsquo;ом;</li><li>для обеспечения &ldquo;гарантированной&rdquo; доли CPU на машине.</li></ul><p>Ранее писал <a href=https://habr.com/ru/companies/samokat_tech/articles/735638/>про это применительно к специфике JVM</a>.</p><p>А вот механизмы вокруг memory таким похвастать не могут - реквесты используются только для выбора подходящей ноды.</p><p>С другой стороны <strong>docker</strong> умеет работать с soft limits через флаг <a href=https://docs.docker.com/config/containers/resource_constraints/#limit-a-containers-access-to-memory><code>--memory-reservation</code></a>, что расширяет потенциальную область применимости.</p><h3 id=к-тестам>К тестам<a hidden class=anchor aria-hidden=true href=#к-тестам>#</a></h3><p>Дано:</p><ul><li>виртуальная машина с debian 11 и 8Gb RAM;</li><li>docker v20.10.17;</li><li>набор контейнеров, алоцирующие по 1Gb анонимной памяти каждый.</li></ul><p>Для воспроизведения код аллокации:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=kn>import</span> <span class=nn>numpy</span> <span class=k>as</span> <span class=nn>np</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>def</span> <span class=nf>allocate_memory</span><span class=p>(</span><span class=n>size_in_gb</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=n>size_in_bytes</span> <span class=o>=</span> <span class=n>size_in_gb</span> <span class=o>*</span> <span class=mi>1024</span><span class=o>**</span><span class=mi>3</span>
</span></span><span class=line><span class=cl>    <span class=n>num_elements</span> <span class=o>=</span> <span class=n>size_in_bytes</span> <span class=o>//</span> <span class=n>np</span><span class=o>.</span><span class=n>dtype</span><span class=p>(</span><span class=s1>&#39;float64&#39;</span><span class=p>)</span><span class=o>.</span><span class=n>itemsize</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=n>memory_block</span> <span class=o>=</span> <span class=n>np</span><span class=o>.</span><span class=n>zeros</span><span class=p>(</span><span class=n>num_elements</span><span class=p>,</span> <span class=n>dtype</span><span class=o>=</span><span class=s1>&#39;float64&#39;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=n>i</span> <span class=ow>in</span> <span class=nb>range</span><span class=p>(</span><span class=n>num_elements</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=n>memory_block</span><span class=p>[</span><span class=n>i</span><span class=p>]</span> <span class=o>=</span> <span class=n>i</span> <span class=o>%</span> <span class=mi>256</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>while</span> <span class=kc>True</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=k>pass</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>if</span> <span class=vm>__name__</span> <span class=o>==</span> <span class=s2>&#34;__main__&#34;</span><span class=p>:</span>
</span></span><span class=line><span class=cl>    <span class=n>allocate_memory</span><span class=p>(</span><span class=mi>1</span><span class=p>)</span>
</span></span></code></pre></div><p>и <code>Dockerfile</code>:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-Dockerfile data-lang=Dockerfile><span class=line><span class=cl><span class=k>FROM</span><span class=s> python:3.9-slim</span><span class=err>
</span></span></span><span class=line><span class=cl><span class=err></span><span class=k>WORKDIR</span><span class=s> /app</span><span class=err>
</span></span></span><span class=line><span class=cl><span class=err></span><span class=k>RUN</span> pip install numpy<span class=err>
</span></span></span><span class=line><span class=cl><span class=err></span><span class=k>COPY</span> allocate_memory.py .<span class=err>
</span></span></span><span class=line><span class=cl><span class=err></span><span class=k>CMD</span> <span class=p>[</span><span class=s2>&#34;python&#34;</span><span class=p>,</span> <span class=s2>&#34;allocate_memory.py&#34;</span><span class=p>]</span><span class=err>
</span></span></span></code></pre></div><p>Зафиксируем объем свободной памяти:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl><span class=c1># free -h</span>
</span></span><span class=line><span class=cl>              total        used        free      shared  buff/cache   available
</span></span><span class=line><span class=cl>Mem:          7,8Gi       656Mi       6,8Gi        79Mi       339Mi       6,8Gi
</span></span><span class=line><span class=cl>Swap:            0B          0B          0B
</span></span></code></pre></div><p>И начнем запускаться в разных конфигурациях.</p><h4 id=1-семь-контейнеров-без-софт-лимитов>1. Семь контейнеров без софт лимитов<a hidden class=anchor aria-hidden=true href=#1-семь-контейнеров-без-софт-лимитов>#</a></h4><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl><span class=c1># for i in {1..7}; do docker run --rm -d mem-anon-1gb; done</span>
</span></span><span class=line><span class=cl>74a5212e5061d3f4f5cf71af116fc4b151997c58f76e453a16260354106b2ba0
</span></span><span class=line><span class=cl>a0cdf9b5c7d43c894b2820cf66a22e5e412781cfda670ca4727dac75a82f1d07
</span></span><span class=line><span class=cl>eb2367e472efbce609f4859acbebc82b97830765765a240dcaef8509ec4c5712
</span></span><span class=line><span class=cl>4288b784bcd239b3c11deaa71886adf5c59792edaffaadcad23a9b7335c2b24d
</span></span><span class=line><span class=cl>8ed56c614be71159f9e64347cfb601e18092e3c65bd1e069beed13c11bb59f34
</span></span><span class=line><span class=cl>aa1425bae3f5652d0f38b0658d384adb22de6334a55b604ac69940755854ce4e
</span></span><span class=line><span class=cl>79ebce488f401397e52a1171dd3b5652d2b11a52d9e4b000d53038bdf6b78053
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># free -h</span>
</span></span><span class=line><span class=cl>              total        used        free      shared  buff/cache   available
</span></span><span class=line><span class=cl>Mem:          7,8Gi       7,5Gi       124Mi        79Mi       150Mi        23Mi
</span></span><span class=line><span class=cl>Swap:            0B          0B          0B
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># docker stats --no-stream --format &#34;{{.Container}}: {{.MemUsage}}&#34;</span>
</span></span><span class=line><span class=cl>74a5212e5061: 628.3MiB / 7.791GiB
</span></span><span class=line><span class=cl>a0cdf9b5c7d4: 1.019GiB / 7.791GiB
</span></span><span class=line><span class=cl>eb2367e472ef: 1.022GiB / 7.791GiB
</span></span><span class=line><span class=cl>4288b784bcd2: 1.018GiB / 7.791GiB
</span></span><span class=line><span class=cl>8ed56c614be7: 1.022GiB / 7.791GiB
</span></span><span class=line><span class=cl>aa1425bae3f5: 1.024GiB / 7.791GiB
</span></span><span class=line><span class=cl>79ebce488f40: 1.026GiB / 7.791GiB
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>### прошло несколько минут...</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># docker ps -a</span>
</span></span><span class=line><span class=cl>...
</span></span><span class=line><span class=cl>a0cdf9b5c7d4   ...   Exited <span class=o>(</span>137<span class=o>)</span> <span class=m>55</span> seconds ago             ...
</span></span><span class=line><span class=cl>...
</span></span></code></pre></div><p>При запуске седьмого контейнера иссякла память и <strong>docker</strong> отправил <code>SIGKILL</code> в рандомный контейнер для ее высвобождения:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl><span class=c1># free -h</span>
</span></span><span class=line><span class=cl>              total        used        free      shared  buff/cache   available
</span></span><span class=line><span class=cl>Mem:          7,8Gi       6,8Gi       604Mi        79Mi       454Mi       726Mi
</span></span><span class=line><span class=cl>Swap:            0B          0B          0B
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># docker stats --no-stream --format &#34;{{.Container}}: {{.MemUsage}}&#34;</span>
</span></span><span class=line><span class=cl>74a5212e5061: 1.019GiB / 7.791GiB
</span></span><span class=line><span class=cl>eb2367e472ef: 1.018GiB / 7.791GiB
</span></span><span class=line><span class=cl>4288b784bcd2: 1.022GiB / 7.791GiB
</span></span><span class=line><span class=cl>8ed56c614be7: 1.024GiB / 7.791GiB
</span></span><span class=line><span class=cl>aa1425bae3f5: 1.026GiB / 7.791GiB
</span></span><span class=line><span class=cl>79ebce488f40: 1.022GiB / 7.791GiB
</span></span></code></pre></div><h4 id=2-семь-контейнеров-без-софт-лимитов--swap-в-2gb>2. Семь контейнеров без софт лимитов + swap в 2Gb<a hidden class=anchor aria-hidden=true href=#2-семь-контейнеров-без-софт-лимитов--swap-в-2gb>#</a></h4><ol><li>Создадим swap раздел:</li></ol><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>sudo fallocate -l 2G /swapfile
</span></span><span class=line><span class=cl>sudo chmod <span class=m>600</span> /swapfile
</span></span><span class=line><span class=cl>sudo mkswap /swapfile
</span></span><span class=line><span class=cl>sudo swapon /swapfile
</span></span></code></pre></div><ol start=2><li>Запустим первые шесть контейнеров:</li></ol><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl><span class=c1># for i in {1..6}; do docker run --rm -d mem-anon-1gb; done</span>
</span></span><span class=line><span class=cl>81511a32dc43b8f26610d4ed34891a846bb730b1e64bfb4bf269d388b6910f39
</span></span><span class=line><span class=cl>caf7ce67ae058a0979f1ddf81062efd708807e958167ea93fdc1bc2f236c69ee
</span></span><span class=line><span class=cl>f7976d6d00c9530936f37702aae24f130e83c70441f98c7804d33b146adc9fd2
</span></span><span class=line><span class=cl>696f0950addd7c838ca20fa6a89ed8c4f55ee1043a903d729db140dc997f0fb1
</span></span><span class=line><span class=cl>82aa3421260f22f0a94acb3f74aea201e4dc0c7c2f1fd6fb29449e66b26e7a15
</span></span><span class=line><span class=cl>e83b17188939bc27693416abeef368ebc301516f27cf54a070e1ba0a0728eafa
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># free -h</span>
</span></span><span class=line><span class=cl>              total        used        free      shared  buff/cache   available
</span></span><span class=line><span class=cl>Mem:          7,8Gi       6,8Gi       653Mi        31Mi       377Mi       746Mi
</span></span><span class=line><span class=cl>Swap:         2,0Gi         0Gi       2,0Gi
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># docker stats --no-stream --format &#34;{{.Container}}: {{.MemUsage}}&#34;</span>
</span></span><span class=line><span class=cl>e83b17188939: 1.022GiB / 7.791GiB
</span></span><span class=line><span class=cl>82aa3421260f: 1.024GiB / 7.791GiB
</span></span><span class=line><span class=cl>696f0950addd: 1.026GiB / 7.791GiB
</span></span><span class=line><span class=cl>f7976d6d00c9: 1.026GiB / 7.791GiB
</span></span><span class=line><span class=cl>caf7ce67ae05: 1.03GiB / 7.791GiB
</span></span><span class=line><span class=cl>81511a32dc43: 1.033GiB / 7.791GiB
</span></span></code></pre></div><p>Все контейнеры помещаются в оперативной памяти.</p><ol start=3><li>Добавим седьмой:</li></ol><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl><span class=c1># docker run --rm -d mem-anon-1gb</span>
</span></span><span class=line><span class=cl>f4451acbedcabd9f725dcdeae6c0982550dbac66ebd2c2f6501f951b6a4a9204
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># docker stats --no-stream --format &#34;{{.Container}}: {{.MemUsage}}&#34;</span>
</span></span><span class=line><span class=cl>f4451acbedca: 1.016GiB / 7.791GiB
</span></span><span class=line><span class=cl>e83b17188939: 1013MiB / 7.791GiB
</span></span><span class=line><span class=cl>82aa3421260f: 1003MiB / 7.791GiB
</span></span><span class=line><span class=cl>696f0950addd: 986MiB / 7.791GiB
</span></span><span class=line><span class=cl>f7976d6d00c9: 965.6MiB / 7.791GiB
</span></span><span class=line><span class=cl>caf7ce67ae05: 947.8MiB / 7.791GiB
</span></span><span class=line><span class=cl>81511a32dc43: 1.028GiB / 7.791GiB
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># free -h</span>
</span></span><span class=line><span class=cl>              total        used        free      shared  buff/cache   available
</span></span><span class=line><span class=cl>Mem:          7,8Gi       7,4Gi       141Mi        19Mi       259Mi       127Mi
</span></span><span class=line><span class=cl>Swap:         2,0Gi       513Mi       1,5Gi
</span></span></code></pre></div><p>Как только память опустилась до минимально разрешенного уровня начался процесс свопинга, что унесло часть анонимной памяти рандомных контейнеров в swap.</p><h4 id=3-шесть-контейнеров-без-софт-лимитов--один-с-софт-лимитом-в-05gb--swap-в-2gb>3. Шесть контейнеров без софт лимитов + один с софт лимитом в 0.5Gb + swap в 2Gb<a hidden class=anchor aria-hidden=true href=#3-шесть-контейнеров-без-софт-лимитов--один-с-софт-лимитом-в-05gb--swap-в-2gb>#</a></h4><ol><li>Запустим конейтенер с софт лимитами:</li></ol><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl><span class=c1># docker run --rm -d --memory-reservation=&#34;0.5g&#34; mem-anon-1gb</span>
</span></span><span class=line><span class=cl>601e16e8ad6fca2990242c8b7b2617a8d042c9eef27ad4d15b5a7ad30c823f4d
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># docker stats --no-stream --format &#34;{{.Container}}: {{.MemUsage}}&#34;</span>
</span></span><span class=line><span class=cl>601e16e8ad6f: 1.03GiB / 7.791GiB
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># free -h</span>
</span></span><span class=line><span class=cl>              total        used        free      shared  buff/cache   available
</span></span><span class=line><span class=cl>Mem:          7,8Gi       1,6Gi       5,8Gi        28Mi       366Mi       5,9Gi
</span></span><span class=line><span class=cl>Swap:         2,0Gi         0Gi       2,0Gi
</span></span></code></pre></div><p>Контейнер полностью поместился в RAM.</p><ol start=2><li>Добавим остальные шесть без лимитов:</li></ol><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl><span class=c1># for i in {1..6}; do docker run --rm -d mem-anon-1gb; done</span>
</span></span><span class=line><span class=cl>a25f97d7b5954542a4f1fe5227adefecc31e2c4f0c3fec30bc5c238c03e37122
</span></span><span class=line><span class=cl>571e76046aaf0af4e9ebca68b7e2da07d9468cc3ab0d473693a65ee6338dd621
</span></span><span class=line><span class=cl>7c152c4d7973b6d8e16618d7a673022a1b388dbd66767905af2566df26fffd3e
</span></span><span class=line><span class=cl>02c7d1be0ab2633623a8cd604b48d9f2e047954ed7feeda2289cfb6e253e17e6
</span></span><span class=line><span class=cl>948a95bd17ab294af18b899cbc1f6177a41b0ad540825020dbc978b6efc50f60
</span></span><span class=line><span class=cl>18ca4b465ee5229ee837bb5b22916e37009aa7ab56d341221873719df730a26c
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># free -h</span>
</span></span><span class=line><span class=cl>              total        used        free      shared  buff/cache   available
</span></span><span class=line><span class=cl>Mem:          7,8Gi       7,3Gi       141Mi        29Mi       372Mi       230Mi
</span></span><span class=line><span class=cl>Swap:         2,0Gi       558Mi       1,5Gi
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># docker stats --no-stream --format &#34;{{.Container}}: {{.MemUsage}}&#34;</span>
</span></span><span class=line><span class=cl>18ca4b465ee5: 1.018GiB / 7.791GiB
</span></span><span class=line><span class=cl>948a95bd17ab: 1.018GiB / 7.791GiB
</span></span><span class=line><span class=cl>02c7d1be0ab2: 1.018GiB / 7.791GiB
</span></span><span class=line><span class=cl>7c152c4d7973: 1.018GiB / 7.791GiB
</span></span><span class=line><span class=cl>571e76046aaf: 1.018GiB / 7.791GiB
</span></span><span class=line><span class=cl>a25f97d7b595: 1.018GiB / 7.791GiB
</span></span><span class=line><span class=cl>601e16e8ad6f: 610.4MiB / 7.791GiB
</span></span></code></pre></div><p>Все как завещали в документации - контейнер с софт лимитами (<code>601e16e8ad6f</code>) &ldquo;стротлился&rdquo; в swap. Работает!</p><h3 id=выводы>Выводы<a hidden class=anchor aria-hidden=true href=#выводы>#</a></h3><p>Софт лимиты интересный функционал способный мягко ограничивать потребление памяти при ее нехватки в системе, что добавляет гибкости при выстраивания различных уровней QoS.</p><p>Можно сказать, что это аналог механизма троттлинга CPU.</p><p>Из особенностей:</p><ul><li>софт лимиты не гарантируют высвобождения памяти (best-effort), но стараться будут;</li><li>не используются в <strong>kubernetes</strong> (но есть в <strong>docker</strong>);</li><li>для вытестенения анонимной памяти потребуется swap раздел;</li><li>для вытеснения file-backed памяти ничего дополнительно не потребуется - данные будут перетекать из page cache на диск;</li><li>стоит не забывать о пенальти на производительность при работе с дисками.</li></ul><blockquote><p>Будет здорово узнать ваши кейсы: кто, как и зачем использует софт лимиты в своих системах! Велкам в комменты.</p></blockquote><p>Удачи!</p></div><footer class=post-footer><ul class=post-tags><li><a href=https://alebsys.github.io/tags/memory/>Memory</a></li><li><a href=https://alebsys.github.io/tags/cgroup/>Cgroup</a></li><li><a href=https://alebsys.github.io/tags/linux/>Linux</a></li><li><a href=https://alebsys.github.io/tags/docker/>Docker</a></li></ul></footer><div id=disqus_thread></div><script>window.disqus_config=function(){},function(){if(["localhost","127.0.0.1"].indexOf(window.location.hostname)!=-1){document.getElementById("disqus_thread").innerHTML="Disqus comments not available by default when the website is previewed locally.";return}var t=document,e=t.createElement("script");e.async=!0,e.src="//https-alebsys-github-io.disqus.com/embed.js",e.setAttribute("data-timestamp",+new Date),(t.head||t.body).appendChild(e)}()</script><noscript>Please enable JavaScript to view the <a href=https://disqus.com/?ref_noscript>comments powered by Disqus.</a></noscript><a href=https://disqus.com class=dsq-brlink>comments powered by <span class=logo-disqus>Disqus</span></a></article></main><footer class=footer><span>&copy; 2024 <a href=https://alebsys.github.io/>Lebedev Aleksandr</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>