<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Long way to the application, №1. | Lebedev Aleksandr</title>
<meta name=keywords content="network,linux,virtualization,tcp,tuning"><meta name=description content="Прежде чем сетевой пакет из сервиса А попадет в сервис Б, ему следует миновать множество систем по середине, где он сделает ни одну остановку.
И, что самое интересное, никто (или ничто) не гарантируем ему успех в конечно счете.
Описать полный путь мне не хватит ни знаний, ни терпения, поэтому сосредоточусь только на конечной части маршрута - пакет прибыл на целевой Хост, где живет сервис Б.
Цели заметки:
показать через какие остановки, считай очереди, проходит сетевой пакет прежде чем достигнет получателя; как мы можем эти очереди мониторить и как на них влиять."><meta name=author content><link rel=canonical href=https://alebsys.github.io/posts/long-way-to-the-app-1/><meta name=google-site-verification content="XYZabc"><meta name=yandex-verification content="XYZabc"><meta name=msvalidate.01 content="XYZabc"><link crossorigin=anonymous href=/assets/css/stylesheet.a34d62e564cfbcf98a7cbba67f377fd3d6fced4d48b2155a08723ae31c875712.css integrity="sha256-o01i5WTPvPmKfLumfzd/09b87U1IshVaCHI64xyHVxI=" rel="preload stylesheet" as=style><link rel=icon href=https://alebsys.github.io/%3Clink%20/%20abs%20url%3E><link rel=icon type=image/png sizes=16x16 href=https://alebsys.github.io/%3Clink%20/%20abs%20url%3E><link rel=icon type=image/png sizes=32x32 href=https://alebsys.github.io/%3Clink%20/%20abs%20url%3E><link rel=apple-touch-icon href=https://alebsys.github.io/%3Clink%20/%20abs%20url%3E><link rel=mask-icon href=https://alebsys.github.io/%3Clink%20/%20abs%20url%3E><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://alebsys.github.io/posts/long-way-to-the-app-1/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script async src="https://www.googletagmanager.com/gtag/js?id=G-VDR541GTVE"></script><script>var doNotTrack=!1;if(!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-VDR541GTVE",{anonymize_ip:!1})}</script><meta property="og:title" content="Long way to the application, №1."><meta property="og:description" content="Прежде чем сетевой пакет из сервиса А попадет в сервис Б, ему следует миновать множество систем по середине, где он сделает ни одну остановку.
И, что самое интересное, никто (или ничто) не гарантируем ему успех в конечно счете.
Описать полный путь мне не хватит ни знаний, ни терпения, поэтому сосредоточусь только на конечной части маршрута - пакет прибыл на целевой Хост, где живет сервис Б.
Цели заметки:
показать через какие остановки, считай очереди, проходит сетевой пакет прежде чем достигнет получателя; как мы можем эти очереди мониторить и как на них влиять."><meta property="og:type" content="article"><meta property="og:url" content="https://alebsys.github.io/posts/long-way-to-the-app-1/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2024-04-21T00:00:00+00:00"><meta property="article:modified_time" content="2024-04-21T00:00:00+00:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="Long way to the application, №1."><meta name=twitter:description content="Прежде чем сетевой пакет из сервиса А попадет в сервис Б, ему следует миновать множество систем по середине, где он сделает ни одну остановку.
И, что самое интересное, никто (или ничто) не гарантируем ему успех в конечно счете.
Описать полный путь мне не хватит ни знаний, ни терпения, поэтому сосредоточусь только на конечной части маршрута - пакет прибыл на целевой Хост, где живет сервис Б.
Цели заметки:
показать через какие остановки, считай очереди, проходит сетевой пакет прежде чем достигнет получателя; как мы можем эти очереди мониторить и как на них влиять."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://alebsys.github.io/posts/"},{"@type":"ListItem","position":2,"name":"Long way to the application, №1.","item":"https://alebsys.github.io/posts/long-way-to-the-app-1/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Long way to the application, №1.","name":"Long way to the application, №1.","description":"Прежде чем сетевой пакет из сервиса А попадет в сервис Б, ему следует миновать множество систем по середине, где он сделает ни одну остановку.\nИ, что самое интересное, никто (или ничто) не гарантируем ему успех в конечно счете.\nОписать полный путь мне не хватит ни знаний, ни терпения, поэтому сосредоточусь только на конечной части маршрута - пакет прибыл на целевой Хост, где живет сервис Б.\nЦели заметки:\nпоказать через какие остановки, считай очереди, проходит сетевой пакет прежде чем достигнет получателя; как мы можем эти очереди мониторить и как на них влиять.","keywords":["network","linux","virtualization","tcp","tuning"],"articleBody":"Прежде чем сетевой пакет из сервиса А попадет в сервис Б, ему следует миновать множество систем по середине, где он сделает ни одну остановку.\nИ, что самое интересное, никто (или ничто) не гарантируем ему успех в конечно счете.\nОписать полный путь мне не хватит ни знаний, ни терпения, поэтому сосредоточусь только на конечной части маршрута - пакет прибыл на целевой Хост, где живет сервис Б.\nЦели заметки:\nпоказать через какие остановки, считай очереди, проходит сетевой пакет прежде чем достигнет получателя; как мы можем эти очереди мониторить и как на них влиять. Вводные - общение происходит по TCP протоколу, где конечный Хост работает под Linux. И пусть это будет виртуальная машина.\nИ так, пакет прибыл на Хост… Первым делом он попадает в сетевую карту (NIC). Через DMA сетевая карта сохраняет его в оперативной памяти в виде структуры sk_buff в кольцевом буфере RX (входящей) очереди.\nИ это первая остановка.\nВ зависимости от модели сетевой карты RX очередь, как и их количество, можем конфигурировать через ethtool утилиту:\nethtool -l # посмотреть текущее и максимальное количество очередей ethtool -L rx N # изменить текущее количество очередей ethtool -g # посмотреть текущее и максимальную длину очереди ethtool -G rx N # изменить текущий размер очереди Надо заметить, что определенную очередь будет вычищать определенный CPU, потому в вакууме можно сделать вывод, что чем их очередей больше, тем более равномерно распределяется нагрузка на систему.\nНо всегда есть нюансы, о которых полезно помнить и проверять:\nа не хотим ли мы оставлять обработку трафика специально выделенным под это CPU? Трафик на одних ядрах, сервисы живут на других…меньше прерываний, повышение локальности кешей… а что если у нас половина ядер “нечестных” (включен hyperthreading), будут ли 32 очереди на 16 настоящих ядрах (32 виртуальных) работать быстрее нежели к примеру 8 очередей с теми же вводными? Вообщем есть о чем подумать и что потестировать.\nНаблюдать за переполнением возможно через файлы:\n/sys/class/net//statistics/rx_dropped; /proc/net/dev. node_exporter любезно собирает эти данные через метрику node_network_receive_drop_total , что доступна на стандартном дашборде Node Exporter Full.\n💡 Еще одна пометка - я сознательно пропускаю из рассмотрения такую штуку как Qdisc (queuing discipline), надеюсь вернуться к ней в будущем.\nПосле того как систему через прерывания (hard/soft) известили о наличии пакета, рутина ядра softirqd выгребает его из RX, обрабатывает и в конечном счете складывает в txqueue tun/tap интерфейса.\nЭто тот, который одной стороной смотрит на хостовую машину, а другой в виртуальную.\nПодробнее про реализацию читай в блоге cloudflare.\nУзнать длину очереди (qlen) можно командой:\nip a | grep tap69035i0 43: tap30035i0: mtu 1500 qdisc pfifo_fast master fwbr30035i0 state UNKNOWN group default qlen 1000 где tap69035i0 имя интерфейса ВМ с точки зрения гипервизора, в proxmox задается параметром ifname.\nВ нашем случае qlen равна 1000.\nИнтересно, что очередь называется txqueue, то есть исходящая, так как с точки зрения гипервизора пакет покидает Хост, направляясь дальше к Виртуальной машине. Это может вводить в заблуждение.\nСледить за переполнением на хостовой машине помогает файлики:\n/sys/class/net//statistics/tx_dropped; /proc/net/dev. node_exporter отслеживает эти события через node_network_transmit_drop_total.\nИзменяется стандартное значение через\nip link set dev* txqueuelen N Стоит отметить, что переполнение txqueue tap/tun интерфейса часто упускается из рассмотрения, так как метрика принадлежит гипервизору, что полностью скрыто от уровня виртуальной машины. Постараемся решить эту проблему далее.\nНаконец пакет готов подняться на уровень виртуальной машины. Рассмотрим его в следующей заметке.\nУдачи!\n","wordCount":"549","inLanguage":"en","datePublished":"2024-04-21T00:00:00Z","dateModified":"2024-04-21T00:00:00Z","mainEntityOfPage":{"@type":"WebPage","@id":"https://alebsys.github.io/posts/long-way-to-the-app-1/"},"publisher":{"@type":"Organization","name":"Lebedev Aleksandr","logo":{"@type":"ImageObject","url":"https://alebsys.github.io/%3Clink%20/%20abs%20url%3E"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://alebsys.github.io/ accesskey=h title="Lebedev Aleksandr (Alt + H)"><img src=https://alebsys.github.io/apple-touch-icon.png alt aria-label=logo height=35>Lebedev Aleksandr</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://alebsys.github.io/>Home</a>&nbsp;»&nbsp;<a href=https://alebsys.github.io/posts/>Posts</a></div><h1 class="post-title entry-hint-parent">Long way to the application, №1.</h1><div class=post-meta><span title='2024-04-21 00:00:00 +0000 UTC'>April 21, 2024</span>&nbsp;·&nbsp;3 min</div></header><div class=post-content><p>Прежде чем сетевой пакет из сервиса А попадет в сервис Б, ему следует миновать множество систем по середине, где он сделает ни одну остановку.</p><p>И, что самое интересное, никто (или ничто) не гарантируем ему успех в конечно счете.</p><p>Описать полный путь мне не хватит ни знаний, ни терпения, поэтому сосредоточусь только на конечной части маршрута - пакет прибыл на целевой Хост, где живет сервис Б.</p><p>Цели заметки:</p><ol><li>показать через какие остановки, считай очереди, проходит сетевой пакет прежде чем достигнет получателя;</li><li>как мы можем эти очереди мониторить и как на них влиять.</li></ol><p>Вводные - общение происходит по TCP протоколу, где конечный Хост работает под Linux. И пусть это будет виртуальная машина.</p><h3 id=и-так-пакет-прибыл-на-хост>И так, пакет прибыл на Хост…<a hidden class=anchor aria-hidden=true href=#и-так-пакет-прибыл-на-хост>#</a></h3><p>Первым делом он попадает в сетевую карту (<strong>NIC</strong>). Через <strong>DMA</strong> сетевая карта сохраняет его в оперативной памяти в виде структуры <a href=https://elixir.bootlin.com/linux/latest/source/include/linux/skbuff.h#L850>sk_buff</a> в кольцевом буфере <code>RX</code> (входящей) очереди.</p><p>И это <strong>первая</strong> <strong>остановка</strong>.</p><p>В зависимости от модели сетевой карты <code>RX</code> очередь, как и их количество, можем конфигурировать через <code>ethtool</code> утилиту:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>ethtool -l &lt;interface name&gt; <span class=c1># посмотреть текущее и максимальное количество очередей</span>
</span></span><span class=line><span class=cl>ethtool -L &lt;interface name&gt; rx N <span class=c1># изменить текущее количество очередей</span>
</span></span><span class=line><span class=cl>ethtool -g &lt;interface name&gt; <span class=c1># посмотреть текущее и максимальную длину очереди</span>
</span></span><span class=line><span class=cl>ethtool -G &lt;interface name&gt; rx N <span class=c1># изменить текущий размер очереди</span>
</span></span></code></pre></div><p>Надо заметить, что определенную очередь будет вычищать определенный CPU, потому в вакууме можно сделать вывод, что чем их очередей больше, тем более равномерно распределяется нагрузка на систему.</p><p>Но всегда есть нюансы, о которых полезно помнить и проверять:</p><ul><li>а не хотим ли мы оставлять обработку трафика специально выделенным под это CPU? Трафик на одних ядрах, сервисы живут на других…меньше прерываний, повышение локальности кешей…</li><li>а что если у нас половина ядер “нечестных” (включен hyperthreading), будут ли 32 очереди на 16 настоящих ядрах (32 виртуальных) работать быстрее нежели к примеру 8 очередей с теми же вводными?</li></ul><p>Вообщем есть о чем подумать и что потестировать.</p><p>Наблюдать за переполнением возможно через файлы:</p><ul><li><code>/sys/class/net/&lt;interface name>/statistics/rx_dropped</code>;</li><li><code>/proc/net/dev</code>.</li></ul><p><strong>node_exporter</strong> любезно собирает эти данные через метрику <code>node_network_receive_drop_total</code> , что доступна на стандартном дашборде <a href=https://grafana.com/grafana/dashboards/1860-node-exporter-full/>Node Exporter Full</a>.</p><p>💡 Еще одна пометка - я сознательно пропускаю из рассмотрения такую штуку как <strong>Qdisc</strong> (queuing discipline), надеюсь вернуться к ней в будущем.</p><p>После того как систему через прерывания (hard/soft) известили о наличии пакета, рутина ядра <code>softirqd</code> выгребает его из <code>RX</code>, обрабатывает и в конечном счете складывает в <code>txqueue</code> tun/tap интерфейса.</p><p>Это тот, который одной стороной смотрит на хостовую машину, а другой в виртуальную.</p><p>Подробнее про реализацию читай в <a href=https://blog.cloudflare.com/virtual-networking-101-understanding-tap>блоге</a> cloudflare.</p><p>Узнать длину очереди (<code>qlen</code>) можно командой:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>ip a <span class=p>|</span> grep tap69035i0
</span></span><span class=line><span class=cl>43: tap30035i0: &lt;BROADCAST,MULTICAST,PROMISC,UP,LOWER_UP&gt; mtu <span class=m>1500</span> qdisc pfifo_fast master fwbr30035i0 state UNKNOWN group default qlen <span class=m>1000</span>
</span></span></code></pre></div><p>где <code>tap69035i0</code> имя интерфейса ВМ с точки зрения гипервизора, в <strong>proxmox</strong> задается параметром <code>ifname</code>.</p><p>В нашем случае <code>qlen</code> равна 1000.</p><p>Интересно, что очередь называется <code>txqueue</code>, то есть исходящая, так как с точки зрения гипервизора пакет покидает Хост, направляясь дальше к Виртуальной машине. Это может вводить в заблуждение.</p><p>Следить за переполнением на хостовой машине помогает файлики:</p><ul><li><code>/sys/class/net/&lt;interface name>/statistics/tx_dropped</code>;</li><li><code>/proc/net/dev</code>.</li></ul><p><strong>node_exporter</strong> отслеживает эти события через <code>node_network_transmit_drop_total</code>.</p><p>Изменяется стандартное значение через</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>ip link <span class=nb>set</span> dev* &lt;interface name&gt; txqueuelen N
</span></span></code></pre></div><p>Стоит отметить, что переполнение <code>txqueue</code> <code>tap/tun</code> интерфейса часто упускается из рассмотрения, так как метрика принадлежит гипервизору, что полностью скрыто от уровня виртуальной машины. Постараемся решить эту проблему далее.</p><p>Наконец пакет готов подняться на уровень виртуальной машины. Рассмотрим его в следующей заметке.</p><p>Удачи!</p></div><footer class=post-footer><ul class=post-tags><li><a href=https://alebsys.github.io/tags/network/>Network</a></li><li><a href=https://alebsys.github.io/tags/linux/>Linux</a></li><li><a href=https://alebsys.github.io/tags/virtualization/>Virtualization</a></li><li><a href=https://alebsys.github.io/tags/tcp/>Tcp</a></li><li><a href=https://alebsys.github.io/tags/tuning/>Tuning</a></li></ul></footer><div id=disqus_thread></div><script>window.disqus_config=function(){},function(){if(["localhost","127.0.0.1"].indexOf(window.location.hostname)!=-1){document.getElementById("disqus_thread").innerHTML="Disqus comments not available by default when the website is previewed locally.";return}var t=document,e=t.createElement("script");e.async=!0,e.src="//https-alebsys-github-io.disqus.com/embed.js",e.setAttribute("data-timestamp",+new Date),(t.head||t.body).appendChild(e)}()</script><noscript>Please enable JavaScript to view the <a href=https://disqus.com/?ref_noscript>comments powered by Disqus.</a></noscript><a href=https://disqus.com class=dsq-brlink>comments powered by <span class=logo-disqus>Disqus</span></a></article></main><footer class=footer><span>&copy; 2024 <a href=https://alebsys.github.io/>Lebedev Aleksandr</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>