<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Thread State Analysis | Performance Matters!</title>
<meta name=keywords content="performance,TSA"><meta name=description content="Сессия траблшутинга - это не только конечный результат, но и процесс, протекающий с различной степенью эффективности. Одного умения пользоваться инструментами, знать флаги и уверенно работать в консоли недостаточно. Необходима систематизация."><meta name=author content><link rel=canonical href=https://alebsys.github.io/posts/tsa/><meta name=google-site-verification content="XYZabc"><meta name=yandex-verification content="XYZabc"><meta name=msvalidate.01 content="XYZabc"><link crossorigin=anonymous href=/assets/css/stylesheet.c430ebc989de9834deb71350267c02556038b4e0700f26e58a65099aaeaadc8e.css integrity="sha256-xDDryYnemDTetxNQJnwCVWA4tOBwDyblimUJmq6q3I4=" rel="preload stylesheet" as=style><link rel=icon href=https://alebsys.github.io/%3Clink%20/%20abs%20url%3E><link rel=icon type=image/png sizes=16x16 href=https://alebsys.github.io/%3Clink%20/%20abs%20url%3E><link rel=icon type=image/png sizes=32x32 href=https://alebsys.github.io/%3Clink%20/%20abs%20url%3E><link rel=apple-touch-icon href=https://alebsys.github.io/%3Clink%20/%20abs%20url%3E><link rel=mask-icon href=https://alebsys.github.io/%3Clink%20/%20abs%20url%3E><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://alebsys.github.io/posts/tsa/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script async src="https://www.googletagmanager.com/gtag/js?id=G-VDR541GTVE"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-VDR541GTVE")}</script><meta property="og:title" content="Thread State Analysis"><meta property="og:description" content="Сессия траблшутинга - это не только конечный результат, но и процесс, протекающий с различной степенью эффективности. Одного умения пользоваться инструментами, знать флаги и уверенно работать в консоли недостаточно. Необходима систематизация."><meta property="og:type" content="article"><meta property="og:url" content="https://alebsys.github.io/posts/tsa/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2024-07-10T00:00:00+00:00"><meta property="article:modified_time" content="2024-07-10T00:00:00+00:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="Thread State Analysis"><meta name=twitter:description content="Сессия траблшутинга - это не только конечный результат, но и процесс, протекающий с различной степенью эффективности. Одного умения пользоваться инструментами, знать флаги и уверенно работать в консоли недостаточно. Необходима систематизация."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://alebsys.github.io/posts/"},{"@type":"ListItem","position":2,"name":"Thread State Analysis","item":"https://alebsys.github.io/posts/tsa/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Thread State Analysis","name":"Thread State Analysis","description":"Сессия траблшутинга - это не только конечный результат, но и процесс, протекающий с различной степенью эффективности. Одного умения пользоваться инструментами, знать флаги и уверенно работать в консоли недостаточно. Необходима систематизация.","keywords":["performance","TSA"],"articleBody":"Интро Сессия траблшутинга - это не только конечный результат, но и процесс, протекающий с различной степенью эффективности.\nОдного умения пользоваться инструментами, знать флаги и уверенно работать в консоли недостаточно. Необходима систематизация.\nДля этой цели разработали множество методологий под любой стек и задачу. Часть из них B. Gregg привел в своей книге Systems Performance: USE / RED / Tools / Science методы, Latency Analisys и др.\nМетодологии делятся на:\nверхнеуровневые - фокус на симптомы, пытаются ответить на вопрос “что идет не так”; низкоуровневые - фокус на анализ конкретных компонент, “почему сломалось”. Одна и та же проблема может быть причиной на одном уровне системы и симптомом на другом. Например, медленный ответ от базы данных для бэкенда будет причиной проблемы, тогда как для DBA это симптомом *.\nВ этот раз обсудим верхнеуровневую методологию - Thread State Analisys (TSA):\nThe goal is to identify at a high level where application threads are spending their time, which solves some issues immediately, and directs the investigation of others.\nТеория Суть методологии сводится к отслеживанию сколько по времени и в каком состоянии (state) находятся треды приложения. Где под тредом подразумевается сущность, способная исполняться на процессоре. В linux kernel тред представлен структурой task_struct.\nСостояние треда в linux можно упрощено представить диаграммой: Нас интересуют:\nRunnable (R) - тред готов к исполнению и ожидает очереди в run queue процессора; Running (R) - тред исполняется на процессоре в данный момент; Uninterruptible Sleep (D) - тред заблокирован в ожидании завершения IO операции (сброс данных на диск, etc); Interruptible Sleep (S) - тред заснул в ожидании какого-то события (между интервалами полинга TCP сокета например). И чем дольше тред пребывает в определенном состоянии, тем бОльший интерес оно вызывает для исследований, среди таких может быть:\nпрофилирование в on-cpu режиме (Running); проверка длительности нахождения треда в run queue процессора, а так же длину самой очереди (Runnable); профилирование в off-cpu режиме (D / S); какие системные вызовы используются для обращений к IO (асинхронные / синхронные), их длительность (D); etc Подробнее о типах исследований, а так же в каком порядке их стоит использовать описано в статье The TSA Method.\nТулинг Стандартные утилиты Информация о состоянии тредов процесса доступна в /proc:\n# ls /proc/589/task 589 646 648 650 652 # родительский и дочерние треды процесса # cat /proc/589/task/*/status | grep -E 'State' # моментальный снимок состояния тредов State:\tS (sleeping) State:\tS (sleeping) State:\tS (sleeping) State:\tS (sleeping) State:\tS (sleeping) # tail /proc/589/task/*/wchan # на какой функции ядра тред \"уснул\" ==\u003e /proc/589/task/589/wchan \u003c== futex_wait_queue ==\u003e /proc/589/task/646/wchan \u003c== futex_wait_queue ==\u003e /proc/589/task/648/wchan \u003c== do_epoll_wait ==\u003e /proc/589/task/650/wchan \u003c== futex_wait_queue ==\u003e /proc/589/task/652/wchan \u003c== futex_wait_queue # tail /proc/589/task/*/stack # и как тред до неё добрался ==\u003e /proc/589/task/589/stack \u003c== [\u003c0\u003e] futex_wait_queue+0x60/0x90 [\u003c0\u003e] futex_wait+0x163/0x260 [\u003c0\u003e] do_futex+0x126/0x1c0 [\u003c0\u003e] __x64_sys_futex+0x81/0x1c0 [\u003c0\u003e] do_syscall_64+0x5c/0xc0 [\u003c0\u003e] entry_SYSCALL_64_after_hwframe+0x63/0xcd ==\u003e /proc/589/task/652/stack \u003c== [\u003c0\u003e] do_epoll_wait+0x630/0x760 [\u003c0\u003e] do_compat_epoll_pwait.part.0+0xc/0x70 [\u003c0\u003e] __x64_sys_epoll_pwait+0x7f/0x130 [\u003c0\u003e] do_syscall_64+0x5c/0xc0 [\u003c0\u003e] entry_SYSCALL_64_after_hwframe+0x63/0xcd ... Часть этой информации удобнее получить утилитой ps:\n# ps -eLo s,tid,comm,wchan | grep node_exporter S 589 node_exporter futex_wait_queue S 646 node_exporter futex_wait_queue S 648 node_exporter futex_wait_queue S 650 node_exporter futex_wait_queue S 652 node_exporter do_epoll_wait Все это очень познавательно, но в сыром виде практическая польза от этой информации минимальна.\n0x.tools Это набор скриптов (на python, bash и C) призванный с минимальным оверхедом получать сведения о состоянии тредов из директории /proc, а значит для их работы не требуются (почти) внешние зависимости, что очень актуально в окружениях со старыми версиями ядер.\nУтилита psn позволяет получать агрегированный результат по тредам во времени:\n# psn -p 7121 -d 60 -G syscall,wchan,kstack # для PID 7121, за 60 секунд отобрази только R и D, плюс доп. поля - syscall, wchan, kstask === Active Threads =========================================================================================================================================================================================================================================== samples | avg_threads | comm | state | syscall | wchan | kstack -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- 2158 | 2.52 | (opensearch[os-*) | Running (ON CPU) | [running] | 0 | - 119 | 0.14 | (opensearch[os-*) | Disk (Uninterruptible) | fdatasync | 0 | __x64_sys_fdatasync()-\u003exfs_file_fsync()-\u003exfs_log_force_seq()-\u003exlog_force_lsn() 60 | 0.07 | (opensearch[os-*) | Disk (Uninterruptible) | fdatasync | 0 | __x64_sys_fdatasync()-\u003exfs_file_fsync()-\u003eblkdev_issue_flush()-\u003esubmit_bio_wait() 50 | 0.06 | (opensearch[os-*) | Disk (Uninterruptible) | fdatasync | 0 | __x64_sys_fdatasync()-\u003exfs_file_fsync()-\u003exfs_log_force_seq()-\u003exlog_wait_on_iclog() 48 | 0.06 | (GC Thread#*) | Running (ON CPU) | [running] | 0 | - 43 | 0.05 | (opensearch[os-*) | Running (ON CPU) | [running] | 0 | __x64_sys_epoll_wait()-\u003edo_epoll_wait() 35 | 0.04 | (G* Conc#*) | Running (ON CPU) | [running] | 0 | - 35 | 0.04 | (opensearch[os-*) | Disk (Uninterruptible) | [kernel_thread] | 0 | exc_page_fault()-\u003edo_user_addr_fault()-\u003ehandle_mm_fault()-\u003e__do_fault()-\u003e__xfs_filemap_fault()-\u003efilemap_fault()-\u003ewait_on_page_bit_common() 30 | 0.04 | (opensearch[os-*) | Disk (Uninterruptible) | fdatasync | 0 | - 23 | 0.03 | (opensearch[os-*) | Disk (Uninterruptible) | fdatasync | 0 | __x64_sys_fdatasync()-\u003exfs_file_fsync()-\u003exlog_wait_on_iclog() ... В листинге выше подавляющее количество времени процесс исполнялся на CPU делая (возможно) что-то полезное, небольшие доли у GC и ожидания в D.\nПодобный анализ позволяет нам относительно легко узнать, чем занимаются потоки процесса, и, если необходимо, более детально исследовать определенные аспекты его поведения.\nTSA, как и другие высокоуровневые методологии (USE, RED), может помочь сориентироваться и определить направления для дальнейшего анализа и сократить общее время устранения проблем.\nКстати автор 0xTools вовсю переписывает свои инструменты на bcc (epbf), будем смотреть.\n","wordCount":"830","inLanguage":"en","datePublished":"2024-07-10T00:00:00Z","dateModified":"2024-07-10T00:00:00Z","mainEntityOfPage":{"@type":"WebPage","@id":"https://alebsys.github.io/posts/tsa/"},"publisher":{"@type":"Organization","name":"Performance Matters!","logo":{"@type":"ImageObject","url":"https://alebsys.github.io/%3Clink%20/%20abs%20url%3E"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://alebsys.github.io/ accesskey=h title="Performance matters! (Alt + H)"><img src=https://alebsys.github.io/apple-touch-icon.png alt aria-label=logo height=35>Performance matters!</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://alebsys.github.io/about/ title=About><span>About</span></a></li><li><a href=https://alebsys.github.io/posts/ title=Blog><span>Blog</span></a></li><li><a href=https://alebsys.github.io/for_hr/ title="For HR"><span>For HR</span></a></li><li><a href=https://alebsys.github.io/mentoring/ title=Mentoring><span>Mentoring</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://alebsys.github.io/>Home</a>&nbsp;»&nbsp;<a href=https://alebsys.github.io/posts/>Posts</a></div><h1 class="post-title entry-hint-parent">Thread State Analysis</h1><div class=post-meta><span title='2024-07-10 00:00:00 +0000 UTC'>July 10, 2024</span>&nbsp;·&nbsp;4 min</div></header><div class=post-content><h3 id=интро>Интро<a hidden class=anchor aria-hidden=true href=#интро>#</a></h3><p>Сессия траблшутинга - это не только конечный результат, но и процесс, протекающий с различной степенью эффективности.</p><p>Одного умения пользоваться инструментами, знать флаги и уверенно работать в консоли недостаточно. Необходима систематизация.</p><p>Для этой цели разработали множество методологий под любой стек и задачу. Часть из них B. Gregg привел в своей книге <a href=https://www.amazon.com/Systems-Performance-Brendan-Gregg-ebook/dp/B08J5QZPNC>Systems Performance</a>: USE / RED / Tools / Science методы, Latency Analisys и др.</p><p>Методологии делятся на:</p><ul><li><strong>верхнеуровневые</strong> - фокус на симптомы, пытаются ответить на вопрос &ldquo;<em>что идет не так</em>&rdquo;;</li><li><strong>низкоуровневые</strong> - фокус на анализ конкретных компонент, &ldquo;<em>почему сломалось</em>&rdquo;.</li></ul><p>Одна и та же проблема может быть причиной на одном уровне системы и симптомом на другом. Например, медленный ответ от базы данных для бэкенда будет причиной проблемы, тогда как для DBA это симптомом <a href=https://sre.google/sre-book/monitoring-distributed-systems/>*</a>.</p><p>В этот раз обсудим верхнеуровневую методологию - <em>Thread State Analisys (TSA)</em>:</p><p><em>The goal is to identify at a high level where application threads are spending their time, which solves some issues immediately, and directs the investigation of others.</em></p><h3 id=теория>Теория<a hidden class=anchor aria-hidden=true href=#теория>#</a></h3><p>Суть методологии сводится к отслеживанию <strong>сколько по времени</strong> и <strong>в каком состоянии</strong> (<em>state</em>) <strong>находятся треды</strong> приложения. Где под тредом подразумевается сущность, способная исполняться на процессоре. В linux kernel тред представлен структурой <a href=https://github.com/torvalds/linux/blob/master/include/linux/sched.h#L748>task_struct</a>.</p><p>Состояние треда в linux можно упрощено представить диаграммой:
<img loading=lazy src=/images/tsa/thread_state.png alt=image>
Нас интересуют:</p><ul><li><em>Runnable (R)</em> - тред готов к исполнению и ожидает очереди в <a href=https://en.wikipedia.org/wiki/Run_queue><em>run queue</em></a> процессора;</li><li><em>Running (R)</em> - тред исполняется на процессоре в данный момент;</li><li><em>Uninterruptible Sleep (D)</em> - тред заблокирован в ожидании завершения IO операции (сброс данных на диск, etc);</li><li><em>Interruptible Sleep (S)</em> - тред заснул в ожидании какого-то события (между интервалами полинга TCP сокета например).</li></ul><p>И чем дольше тред пребывает в определенном состоянии, тем бОльший интерес оно вызывает для исследований, среди таких может быть:</p><ul><li>профилирование в <a href=https://www.brendangregg.com/FlameGraphs/cpuflamegraphs.html>on-cpu режиме</a> (<strong>R</strong>unning);</li><li>проверка <a href=https://github.com/iovisor/bcc/blob/master/tools/runqlat_example.txt>длительности нахождения треда</a> в <em>run queue</em> процессора, а так же <a href=https://github.com/iovisor/bcc/blob/master/tools/runqlen_example.txt>длину самой очереди</a> (<strong>R</strong>unnable);</li><li>профилирование в <a href=https://www.brendangregg.com/FlameGraphs/offcpuflamegraphs.html>off-cpu режиме</a> (<strong>D</strong> / <strong>S</strong>);</li><li>какие системные вызовы используются для обращений к IO (асинхронные / синхронные), <a href=https://github.com/iovisor/bcc/blob/master/tools/syscount_example.txt>их длительность</a> (<strong>D</strong>);</li><li>etc</li></ul><blockquote><p>Подробнее о типах исследований, а так же в каком порядке их стоит использовать описано в статье <a href=https://www.brendangregg.com/tsamethod.html>The TSA Method</a>.</p></blockquote><h2 id=тулинг>Тулинг<a hidden class=anchor aria-hidden=true href=#тулинг>#</a></h2><h3 id=стандартные-утилиты>Стандартные утилиты<a hidden class=anchor aria-hidden=true href=#стандартные-утилиты>#</a></h3><p>Информация о состоянии тредов процесса доступна в <code>/proc</code>:</p><pre tabindex=0><code># ls /proc/589/task
589  646  648  650  652 # родительский и дочерние треды процесса

# cat /proc/589/task/*/status | grep -E &#39;State&#39; # моментальный снимок состояния тредов
State:	S (sleeping)
State:	S (sleeping)
State:	S (sleeping)
State:	S (sleeping)
State:	S (sleeping)

#  tail /proc/589/task/*/wchan # на какой функции ядра тред &#34;уснул&#34;
==&gt; /proc/589/task/589/wchan &lt;==
futex_wait_queue
==&gt; /proc/589/task/646/wchan &lt;==
futex_wait_queue
==&gt; /proc/589/task/648/wchan &lt;==
do_epoll_wait
==&gt; /proc/589/task/650/wchan &lt;==
futex_wait_queue
==&gt; /proc/589/task/652/wchan &lt;==
futex_wait_queue

#  tail /proc/589/task/*/stack # и как тред до неё добрался
==&gt; /proc/589/task/589/stack &lt;==
[&lt;0&gt;] futex_wait_queue+0x60/0x90
[&lt;0&gt;] futex_wait+0x163/0x260
[&lt;0&gt;] do_futex+0x126/0x1c0
[&lt;0&gt;] __x64_sys_futex+0x81/0x1c0
[&lt;0&gt;] do_syscall_64+0x5c/0xc0
[&lt;0&gt;] entry_SYSCALL_64_after_hwframe+0x63/0xcd

==&gt; /proc/589/task/652/stack &lt;==
[&lt;0&gt;] do_epoll_wait+0x630/0x760
[&lt;0&gt;] do_compat_epoll_pwait.part.0+0xc/0x70
[&lt;0&gt;] __x64_sys_epoll_pwait+0x7f/0x130
[&lt;0&gt;] do_syscall_64+0x5c/0xc0
[&lt;0&gt;] entry_SYSCALL_64_after_hwframe+0x63/0xcd
...
</code></pre><p>Часть этой информации удобнее получить утилитой <code>ps</code>:</p><pre tabindex=0><code>#  ps -eLo s,tid,comm,wchan | grep node_exporter
S     589 node_exporter   futex_wait_queue
S     646 node_exporter   futex_wait_queue
S     648 node_exporter   futex_wait_queue
S     650 node_exporter   futex_wait_queue
S     652 node_exporter   do_epoll_wait
</code></pre><p>Все это очень познавательно, но в сыром виде практическая польза от этой информации минимальна.</p><h3 id=0xtools>0x.tools<a hidden class=anchor aria-hidden=true href=#0xtools>#</a></h3><p>Это <a href=https://github.com/tanelpoder/0xtools>набор скриптов</a> (на python, bash и C) призванный с минимальным оверхедом получать сведения о состоянии тредов из директории <code>/proc</code>, а значит для их работы не требуются (почти) внешние зависимости, что очень актуально в окружениях со старыми версиями ядер.</p><p>Утилита <code>psn</code> позволяет получать агрегированный результат по тредам во времени:</p><pre tabindex=0><code># psn -p 7121 -d 60 -G syscall,wchan,kstack  # для PID 7121, за 60 секунд отобрази только R и D, плюс доп. поля - syscall, wchan, kstask 
=== Active Threads ===========================================================================================================================================================================================================================================

 samples | avg_threads | comm              | state                  | syscall         | wchan | kstack
--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
    2158 |        2.52 | (opensearch[os-*) | Running (ON CPU)       | [running]       | 0     | -
     119 |        0.14 | (opensearch[os-*) | Disk (Uninterruptible) | fdatasync       | 0     | __x64_sys_fdatasync()-&gt;xfs_file_fsync()-&gt;xfs_log_force_seq()-&gt;xlog_force_lsn()
      60 |        0.07 | (opensearch[os-*) | Disk (Uninterruptible) | fdatasync       | 0     | __x64_sys_fdatasync()-&gt;xfs_file_fsync()-&gt;blkdev_issue_flush()-&gt;submit_bio_wait()
      50 |        0.06 | (opensearch[os-*) | Disk (Uninterruptible) | fdatasync       | 0     | __x64_sys_fdatasync()-&gt;xfs_file_fsync()-&gt;xfs_log_force_seq()-&gt;xlog_wait_on_iclog()
      48 |        0.06 | (GC Thread#*)     | Running (ON CPU)       | [running]       | 0     | -
      43 |        0.05 | (opensearch[os-*) | Running (ON CPU)       | [running]       | 0     | __x64_sys_epoll_wait()-&gt;do_epoll_wait()
      35 |        0.04 | (G* Conc#*)       | Running (ON CPU)       | [running]       | 0     | -
      35 |        0.04 | (opensearch[os-*) | Disk (Uninterruptible) | [kernel_thread] | 0     | exc_page_fault()-&gt;do_user_addr_fault()-&gt;handle_mm_fault()-&gt;__do_fault()-&gt;__xfs_filemap_fault()-&gt;filemap_fault()-&gt;wait_on_page_bit_common()
      30 |        0.04 | (opensearch[os-*) | Disk (Uninterruptible) | fdatasync       | 0     | -
      23 |        0.03 | (opensearch[os-*) | Disk (Uninterruptible) | fdatasync       | 0     | __x64_sys_fdatasync()-&gt;xfs_file_fsync()-&gt;xlog_wait_on_iclog()
...
</code></pre><p>В листинге выше подавляющее количество времени процесс исполнялся на CPU делая (возможно) что-то полезное, небольшие доли у GC и ожидания в <strong>D</strong>.</p><p>Подобный анализ позволяет нам относительно легко узнать, чем занимаются потоки процесса, и, если необходимо, более детально исследовать определенные аспекты его поведения.</p><hr><p>TSA, как и другие высокоуровневые методологии (USE, RED), может помочь сориентироваться и определить направления для дальнейшего анализа и сократить общее время устранения проблем.</p><blockquote><p>Кстати автор 0xTools вовсю переписывает свои инструменты на bcc (epbf), будем смотреть.</p></blockquote></div><footer class=post-footer><ul class=post-tags><li><a href=https://alebsys.github.io/tags/performance/>Performance</a></li><li><a href=https://alebsys.github.io/tags/tsa/>TSA</a></li></ul></footer><div id=disqus_thread></div><script>window.disqus_config=function(){},function(){if(["localhost","127.0.0.1"].indexOf(window.location.hostname)!=-1){document.getElementById("disqus_thread").innerHTML="Disqus comments not available by default when the website is previewed locally.";return}var t=document,e=t.createElement("script");e.async=!0,e.src="//https-alebsys-github-io.disqus.com/embed.js",e.setAttribute("data-timestamp",+new Date),(t.head||t.body).appendChild(e)}()</script><noscript>Please enable JavaScript to view the <a href=https://disqus.com/?ref_noscript>comments powered by Disqus.</a></noscript><a href=https://disqus.com class=dsq-brlink>comments powered by <span class=logo-disqus>Disqus</span></a></article></main><footer class=footer><span>&copy; 2024 <a href=https://alebsys.github.io/>Performance Matters!</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>