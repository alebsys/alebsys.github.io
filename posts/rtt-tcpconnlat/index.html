<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Сетевой анализ с eBPF: измеряем Round Trip Time | Performance Matters</title>
<meta name=keywords content="tcp,linux,ebpf"><meta name=description content="Разбираем сложность интерпретации Latency и пишем свой инструмент на eBPF, который эту сложность снижает."><meta name=author content><link rel=canonical href=https://alebedev.tech/posts/rtt-tcpconnlat/><meta name=google-site-verification content="XYZabc"><meta name=yandex-verification content="XYZabc"><meta name=msvalidate.01 content="XYZabc"><link crossorigin=anonymous href=/assets/css/stylesheet.27100688bec44e71d90b7169778c0eac3af72cdb83d2fd2b79510e30556bd171.css integrity="sha256-JxAGiL7ETnHZC3Fpd4wOrDr3LNuD0v0reVEOMFVr0XE=" rel="preload stylesheet" as=style><link rel=icon href=https://alebedev.tech/images/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://alebedev.tech/%3Clink%20/%20abs%20url%3E><link rel=icon type=image/png sizes=32x32 href=https://alebedev.tech/%3Clink%20/%20abs%20url%3E><link rel=apple-touch-icon href=https://alebedev.tech/%3Clink%20/%20abs%20url%3E><link rel=mask-icon href=https://alebedev.tech/%3Clink%20/%20abs%20url%3E><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://alebedev.tech/posts/rtt-tcpconnlat/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script async src="https://www.googletagmanager.com/gtag/js?id=G-98549RKLMS"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-98549RKLMS")}</script><meta property="og:title" content="Сетевой анализ с eBPF: измеряем Round Trip Time"><meta property="og:description" content="Разбираем сложность интерпретации Latency и пишем свой инструмент на eBPF, который эту сложность снижает."><meta property="og:type" content="article"><meta property="og:url" content="https://alebedev.tech/posts/rtt-tcpconnlat/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2024-12-26T00:00:00+00:00"><meta property="article:modified_time" content="2024-12-26T00:00:00+00:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="Сетевой анализ с eBPF: измеряем Round Trip Time"><meta name=twitter:description content="Разбираем сложность интерпретации Latency и пишем свой инструмент на eBPF, который эту сложность снижает."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://alebedev.tech/posts/"},{"@type":"ListItem","position":2,"name":"Сетевой анализ с eBPF: измеряем Round Trip Time","item":"https://alebedev.tech/posts/rtt-tcpconnlat/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Сетевой анализ с eBPF: измеряем Round Trip Time","name":"Сетевой анализ с eBPF: измеряем Round Trip Time","description":"Разбираем сложность интерпретации Latency и пишем свой инструмент на eBPF, который эту сложность снижает.","keywords":["tcp","linux","ebpf"],"articleBody":"Длительность (latency) — ключевой показатель производительности системы. На первый взгляд всё просто: рост задержки — признак деградации.\nСложность в деталях.\nПредставим: клиент запрашивает статический контент у веб-сервера, и мы замечаем увеличение времени ответа.\nВ чем может быть причина?\nВеб-сервер перегружен, запросы накапливаются в очереди. “Шумный сосед” забил сетевой интерфейс гипервизора. Соединение долго извлекается из пула — проблема локальная. DNS-сервер стал дольше отвечать. Каждая операция состоит из множества этапов, и любой из них может стать узким местом.\nЧто делать? Улучшать наблюдаемость.\nЭтим и займемся :)\nПостановка задачи При анализе задержек хочется быстро и точно определять: проблема на уровне приложения или инфраструктуры?\nУтилита ping кажется хорошим вариантом: измеряет Round Trip Time (RTT) между машинами, исключая уровни выше L3, тем самым предоставляя более менее “чистую” метрику состояния соединения.\nНо есть недостатки:\nРаботает только в реальном времени, отсутствует анализ постфактум. Чтобы сохранить данные для последующего анализа, придется городить дополнительные костыли вокруг ping. Невозможно заранее определить, какое направление сетевого трафика окажется важным. Последний пункт можно закрыть утилитой tcpconnlat (eBPF), которая измеряет время между отправкой SYN и получением SYN-ACK.\nВ отличие от ping, она фиксирует задержки установки соединений для всех исходящих подключений на машине, предоставляя более полное понимание состояния сети:\n# ./tcpconnlat PID COMM IP SADDR DADDR DPORT LAT(ms) 1201 wget 4 10.153.223.157 23.23.100.231 80 1.65 1201 wget 4 10.153.223.157 23.23.100.231 443 1.60 1433 curl 4 10.153.223.157 104.20.25.153 80 0.75 Значения LAT аналогичны RTT от ping, но содержат некоторый “шум”, так как учитывают работу TCP (L4). При этом уровень приложения остается все так же за рамками.\nА чтобы решить проблему исторического анализа адаптируем tcpconnlat под работу с ebpf_exporter - данные будут храниться в виде метрик.\nПишем свой первый eBPF скрипт eBPF позволяет “перехватывать” события в ядре Linux (например, вызов функций) и выполнять пользовательскую логику: считать данные, извлекать значения аргументов или даже изменять их.\nНаша цель:\nПерехватить вызов функции отправки SYN-сегмента, зафиксировать время отправки, отправителя и получателя в структуру данных (map). Перехватить вызов функции получения SYN-ACK-сегмента, найти соответствующую запись из пункта 1. Вычислить разницу между временем отправки и получения. Передать данные для преобразования в метрики. Рассмотрим реализацию TCP поверх IPv4. Версию для IPv6 можно найти на GitHub.\nДля начала определим функции ядра, которые будем отслеживать:\ntcp_v4_connect — инициирует отправку SYN. tcp_rcv_state_process — отслеживает изменения состояния TCP-соединений, включая переход SYN-SENT -\u003e ESTABLISHED. tcp_destroy_sock — удаляет объект сокета, после закрытия соединения. Используем её для очистки от закрытых сокетов. Кстати, для поиска функций ядра, их аргументов и проверки гипотез удобно использовать bpftrace, но про него в другой раз.\nПерехватываем события в ядре Вот так выглядит код перехвата функций и вызов логики обработки событий:\nSEC(\"fentry/tcp_v4_connect\") int BPF_PROG(tcp_v4_connect, struct sock *sk) { return trace_connect(sk); } SEC(\"fentry/tcp_rcv_state_process\") int BPF_PROG(tcp_rcv_state_process, struct sock *sk) { return handle_tcp_rcv_state_process(ctx, sk); } SEC(\"tracepoint/tcp/tcp_destroy_sock\") int tcp_destroy_sock(struct trace_event_raw_tcp_event_sk *ctx) { const struct sock *sk = ctx-\u003eskaddr; bpf_map_delete_elem(\u0026start, \u0026sk); return 0; } Разберем по порядку:\nSEC(...) — макрос сообщает ядру, к какому событию прикрепить eBPF-программу. fentry/... — один из типов eBPF-хуков, различаются функциональностью и накладными расходами. При прочих равных лучше использовать fentry или tracepoint, так как у них более стабильное API и меньший оверхед. tcp_v4_connect — целевое событие в ядре. BPF_PROG — макрос, упрощающий написание eBPF-программ. Он указывает, что эта функция — eBPF-программа, и ядро должно её обработать. В теле функции вызывается пользовательская логика, например trace_connect(). SYN сегмент Когда локальное приложение пытается установить TCP-соединение, ядро вызывает tcp_v4_connect(). Наш eBPF-скрипт перехватывает этот вызов и запускает код из trace_connect(sk), где sk — экземпляр структуры sock.\nsock - структура ядра, представляет собой объект сетевого сокета, содержит: IP адреса, TCP порты, состояние соединения и т.д.\nstatic int trace_connect(const struct sock *sk) { u32 tgid = bpf_get_current_pid_tgid() \u003e\u003e 32; struct piddata piddata = {}; piddata.ts = bpf_ktime_get_ns(); piddata.tgid = tgid; bpf_map_update_elem(\u0026start, \u0026sk, \u0026piddata, 0); return 0; } bpf_get_current_pid_tgid()\nЭтот хелпер возвращает 64-битное значение, где:\nМладшие 32 бита — TID (Thread ID). Старшие 32 бита — TGID (или проще говоря, PID процесса).\nКонструкция \u003e\u003e 32 извлекает старшие 32 бита, чтобы получить PID. создаем экземпляр структуры piddata:\nstruct piddata { u64 ts; // Таймстамп события. u32 tgid; // TGID (PID) процесса. }; bpf_map_update_elem(\u0026start, \u0026sk, \u0026piddata, 0);\nХелпер добавляет или обновляет элемент в карте (map) start, где ключом является sk, а значением — piddata.\nMap (карта) — специальная структура данных, используемая eBPF-программами для хранения и обмена данными. Она работает по принципу словаря или хэш-таблицы: имеет ключи и значения, которые можно быстро находить, добавлять или обновлять.\nОпределение карты start:\nstruct { __uint(type, BPF_MAP_TYPE_HASH); // Тип карты: хэш-таблица. __uint(max_entries, 4096); // Максимальное количество элементов. __type(key, struct sock *); // Тип ключа: указатель на структуру sock. __type(value, struct piddata); // Тип значения: структура piddata. } start SEC(\".maps\"); // Имя карты. Таким образом, при каждом вызове tcp_v4_connect() eBPF-программа сохраняет информацию о времени отправки SYN-сегмента и процессе, который инициировал соединение. Эти данные затем используются для сопоставления с полученными SYN-ACK-сегментами.\nОтветный SYN-ACK Для обработки ответного SYN-ACK ядро вызывает функцию tcp_rcv_state_process(), мы перехватываем её и запускаем handle_tcp_rcv_state_process():\nstatic int handle_tcp_rcv_state_process(void *ctx, const struct sock *sk) { if (BPF_CORE_READ(sk, __sk_common.skc_state) != TCP_SYN_SENT) return 0; struct piddata *piddatap; piddatap = bpf_map_lookup_elem(\u0026start, \u0026sk); if (!piddatap) return 0; int af; af = BPF_CORE_READ(sk, __sk_common.skc_family); switch (af) { case AF_INET: return handle_ipv4(sk, piddatap); case AF_INET6: return handle_ipv6(sk, piddatap); } return 0; } С помощью макроса BPF_CORE_READ читаем поле __sk_common.skc_state - интересует только состояние SYN-SENT. Экзепляр сокета (sk) используется как ключ для поиска данных в карте start. Если данные отсутствуют, выходим из функции. Определяется тип сокета (поле __sk_common.skc_family): AF_UNIX, AF_INET, AF_INET6, AF_NETLINK, …. Для обработки IPv4 (AF_INET) и IPv6 (AF_INET6) используются handle_ipv4() и handle_ipv6() соответственно. static int handle_ipv4(const struct sock *sk, struct piddata *piddatap) { struct ipv4_event event = {}; s64 delta; u64 ts; u64 delta_us; ts = bpf_ktime_get_ns(); // Получаем текущее время delta = (s64)(ts - piddatap-\u003ets); // Вычисляем дельту времени if (delta \u003c 0) goto cleanup; delta_us = delta / 1000U; // Заполняем структуру event event.laddr = BPF_CORE_READ(sk, __sk_common.skc_rcv_saddr); event.daddr = BPF_CORE_READ(sk, __sk_common.skc_daddr); event.main_port = __builtin_bswap16(BPF_CORE_READ(sk, __sk_common.skc_dport)); // Строим гистограмму из карты ipv4_connection_latency_seconds increment_exp2_histogram(\u0026ipv4_connection_latency_seconds, event, delta_us, MAX_LATENCY_SLOT); cleanup: bpf_map_delete_elem(\u0026start, \u0026sk); // Удаляем данные из карты start return 0; } increment_exp2_histogram() - это функция самого ebpf_exporter для создания метрик гистограмного типа, подробнее в документации.\nопределение карты ipv4_connection_latency_seconds:\nstruct { __uint(type, BPF_MAP_TYPE_HASH); __uint(max_entries, (MAX_LATENCY_SLOT + 1) * MAX_PORTS); __type(key, struct ipv4_event); __type(value, u64); } ipv4_connection_latency_seconds SEC(\".maps\"); где ключом выступает структура ipv4_event:\nstruct ipv4_event { u32 laddr; // локальный IP-адрес u32 daddr; // удаленный IP-адрес u16 main_port; // порт удаленной машины u64 bucket; // бакет для гистограммы }; А для записи длительности установки соединения подойдет беззнаковое u64.\nСоздание метрик На этом этапе все данные собраны. Теперь настроим ebpf_exporter для их правильной интерпретации и определим необходимые лейблы.\nСоздадим еще один файл с расширением .yaml:\nmetrics: histograms: # Название карты (map) с финальными данными и описание метрики - name: ipv4_connection_latency_seconds help: IPv4 Connection Latency histogram # Настройка гистограмы. # https://github.com/cloudflare/ebpf_exporter?tab=readme-ov-file#histogram bucket_type: exp2 bucket_min: 0 bucket_max: 26 bucket_multiplier: 0.000001 # Определение лейблов, значения которых соответствуют подрядку полей структуры `ipv4_event`. # https://github.com/cloudflare/ebpf_exporter?tab=readme-ov-file#labels labels: - name: laddr size: 4 decoders: - name: inet_ip - name: daddr size: 4 decoders: - name: inet_ip - name: main_port size: 8 decoders: - name: uint - name: bucket size: 8 decoders: - name: uint Итоги Осталось запустить ebpf_exporter, настроить в Prometheus сбор метрик и построить необходимые графики.\nНапример так:\nhistogram_quantile(0.90, rate(ebpf_exporter_ipv4_connection_latency_seconds_bucket{}[$__rate_interval])) Теперь нам доступны метрики длительности установки соединений: И отвечать на вопрос “в чем причина замедления: в приложении или инфраструктуре?” становится немного проще.\nПолная версия исходного кода доступна на GitHub.\nУдачи!\n","wordCount":"1219","inLanguage":"en","datePublished":"2024-12-26T00:00:00Z","dateModified":"2024-12-26T00:00:00Z","mainEntityOfPage":{"@type":"WebPage","@id":"https://alebedev.tech/posts/rtt-tcpconnlat/"},"publisher":{"@type":"Organization","name":"Performance Matters","logo":{"@type":"ImageObject","url":"https://alebedev.tech/images/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://alebedev.tech/ accesskey=h title="Performance matters! (Alt + H)"><img src=https://alebedev.tech/images/favicon.ico alt aria-label=logo height=35>Performance matters!</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://alebedev.tech/about/ title=About><span>About</span></a></li><li><a href=https://alebedev.tech/posts/ title=Blog><span>Blog</span></a></li><li><a href=https://alebedev.tech/for_hr/ title="For HR"><span>For HR</span></a></li><li><a href=https://alebedev.tech/mentoring/ title=Mentoring><span>Mentoring</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://alebedev.tech/>Home</a>&nbsp;»&nbsp;<a href=https://alebedev.tech/posts/>Posts</a></div><h1 class="post-title entry-hint-parent">Сетевой анализ с eBPF: измеряем Round Trip Time</h1><div class=post-meta><span title='2024-12-26 00:00:00 +0000 UTC'>December 26, 2024</span>&nbsp;·&nbsp;6 min</div></header><div class=post-content><p><strong>Длительность (latency)</strong> — ключевой показатель производительности системы. На первый взгляд всё просто: рост задержки — признак деградации.</p><p>Сложность в деталях.</p><hr><p>Представим: клиент запрашивает статический контент у веб-сервера, и мы замечаем увеличение времени ответа.</p><p>В чем может быть причина?</p><ul><li>Веб-сервер перегружен, запросы накапливаются в очереди.</li><li>&ldquo;Шумный сосед&rdquo; забил сетевой интерфейс гипервизора.</li><li>Соединение долго извлекается из пула — проблема локальная.</li><li>DNS-сервер стал дольше отвечать.</li></ul><p>Каждая операция состоит из множества этапов, и любой из них может стать узким местом.</p><p>Что делать? Улучшать наблюдаемость.</p><p>Этим и займемся :)</p><h3 id=постановка-задачи>Постановка задачи<a hidden class=anchor aria-hidden=true href=#постановка-задачи>#</a></h3><p>При анализе задержек хочется быстро и точно определять: проблема на уровне приложения или инфраструктуры?</p><p>Утилита <strong>ping</strong> кажется хорошим вариантом: измеряет Round Trip Time (RTT) между машинами, исключая уровни выше L3, тем самым предоставляя более менее &ldquo;чистую&rdquo; метрику состояния соединения.</p><p>Но есть недостатки:</p><ul><li>Работает только в реальном времени, отсутствует анализ постфактум.</li><li>Чтобы сохранить данные для последующего анализа, придется городить дополнительные костыли вокруг <strong>ping</strong>.</li><li>Невозможно заранее определить, какое направление сетевого трафика окажется важным.</li></ul><p>Последний пункт можно закрыть утилитой <a href=https://github.com/iovisor/bcc/blob/master/tools/tcpconnlat_example.txt><strong>tcpconnlat</strong></a> (eBPF), которая измеряет время между отправкой SYN и получением SYN-ACK.</p><p>В отличие от <strong>ping</strong>, она фиксирует задержки установки соединений для всех исходящих подключений на машине, предоставляя более полное понимание состояния сети:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl><span class=c1># ./tcpconnlat</span>
</span></span><span class=line><span class=cl>PID    COMM         IP SADDR            DADDR            DPORT LAT<span class=o>(</span>ms<span class=o>)</span>
</span></span><span class=line><span class=cl><span class=m>1201</span>   wget         <span class=m>4</span>  10.153.223.157   23.23.100.231    <span class=m>80</span>    1.65
</span></span><span class=line><span class=cl><span class=m>1201</span>   wget         <span class=m>4</span>  10.153.223.157   23.23.100.231    <span class=m>443</span>   1.60
</span></span><span class=line><span class=cl><span class=m>1433</span>   curl         <span class=m>4</span>  10.153.223.157   104.20.25.153    <span class=m>80</span>    0.75
</span></span></code></pre></div><p>Значения <code>LAT</code> аналогичны RTT от <strong>ping</strong>, но содержат некоторый &ldquo;шум&rdquo;, так как учитывают работу TCP (L4). При этом уровень приложения остается все так же за рамками.</p><p>А чтобы решить проблему исторического анализа адаптируем <strong>tcpconnlat</strong> под работу с <a href=https://github.com/cloudflare/ebpf_exporter><strong>ebpf_exporter</strong></a> - данные будут храниться в виде метрик.</p><h3 id=пишем-свой-первый-ebpf-скрипт>Пишем свой первый eBPF скрипт<a hidden class=anchor aria-hidden=true href=#пишем-свой-первый-ebpf-скрипт>#</a></h3><p>eBPF позволяет &ldquo;перехватывать&rdquo; события в ядре Linux (например, вызов функций) и выполнять пользовательскую логику: считать данные, извлекать значения аргументов или даже изменять их.</p><p>Наша цель:</p><ol><li>Перехватить вызов функции отправки SYN-сегмента, зафиксировать время отправки, отправителя и получателя в структуру данных (map).</li><li>Перехватить вызов функции получения SYN-ACK-сегмента, найти соответствующую запись из пункта 1.</li><li>Вычислить разницу между временем отправки и получения.</li><li>Передать данные для преобразования в метрики.</li></ol><blockquote><p>Рассмотрим реализацию TCP поверх IPv4. Версию для IPv6 можно найти на GitHub.</p></blockquote><hr><p>Для начала определим функции ядра, которые будем отслеживать:</p><ul><li><a href=https://elixir.bootlin.com/linux/v6.1.80/source/net/ipv4/tcp_ipv4.c#L200><code>tcp_v4_connect</code></a> — инициирует отправку SYN.</li><li><a href=https://elixir.bootlin.com/linux/v6.1.80/source/net/ipv4/tcp_input.c#L6465><code>tcp_rcv_state_process</code></a> — отслеживает изменения состояния TCP-соединений, включая переход <code>SYN-SENT -> ESTABLISHED</code>.</li><li><a href=https://elixir.bootlin.com/linux/v6.1.80/source/include/trace/events/tcp.h#L176><code>tcp_destroy_sock</code></a> — удаляет объект сокета, после закрытия соединения. Используем её для очистки от закрытых сокетов.</li></ul><p>Кстати, для поиска функций ядра, их аргументов и проверки гипотез удобно использовать <a href=https://github.com/bpftrace/bpftrace><strong>bpftrace</strong></a>, но про него в другой раз.</p><hr><h3 id=перехватываем-события-в-ядре>Перехватываем события в ядре<a hidden class=anchor aria-hidden=true href=#перехватываем-события-в-ядре>#</a></h3><p>Вот так выглядит код перехвата функций и вызов логики обработки событий:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=nf>SEC</span><span class=p>(</span><span class=s>&#34;fentry/tcp_v4_connect&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>BPF_PROG</span><span class=p>(</span><span class=n>tcp_v4_connect</span><span class=p>,</span> <span class=k>struct</span> <span class=n>sock</span> <span class=o>*</span><span class=n>sk</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=k>return</span> <span class=nf>trace_connect</span><span class=p>(</span><span class=n>sk</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=nf>SEC</span><span class=p>(</span><span class=s>&#34;fentry/tcp_rcv_state_process&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>BPF_PROG</span><span class=p>(</span><span class=n>tcp_rcv_state_process</span><span class=p>,</span> <span class=k>struct</span> <span class=n>sock</span> <span class=o>*</span><span class=n>sk</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=k>return</span> <span class=nf>handle_tcp_rcv_state_process</span><span class=p>(</span><span class=n>ctx</span><span class=p>,</span> <span class=n>sk</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=nf>SEC</span><span class=p>(</span><span class=s>&#34;tracepoint/tcp/tcp_destroy_sock&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>tcp_destroy_sock</span><span class=p>(</span><span class=k>struct</span> <span class=n>trace_event_raw_tcp_event_sk</span> <span class=o>*</span><span class=n>ctx</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=k>const</span> <span class=k>struct</span> <span class=n>sock</span> <span class=o>*</span><span class=n>sk</span> <span class=o>=</span> <span class=n>ctx</span><span class=o>-&gt;</span><span class=n>skaddr</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=nf>bpf_map_delete_elem</span><span class=p>(</span><span class=o>&amp;</span><span class=n>start</span><span class=p>,</span> <span class=o>&amp;</span><span class=n>sk</span><span class=p>);</span>
</span></span><span class=line><span class=cl>	<span class=k>return</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>Разберем по порядку:</p><ol><li><strong><code>SEC(...)</code></strong> — макрос сообщает ядру, к какому событию прикрепить eBPF-программу.</li><li><strong><code>fentry/...</code></strong> — один из <a href=https://github.com/cilium/ebpf/blob/main/examples/README.md>типов eBPF-хуков</a>, различаются функциональностью и накладными расходами. При прочих равных лучше использовать <strong><code>fentry</code></strong> или <strong><code>tracepoint</code></strong>, так как у них более стабильное API и меньший оверхед.</li><li><strong><code>tcp_v4_connect</code></strong> — целевое событие в ядре.</li><li><strong><code>BPF_PROG</code></strong> — макрос, упрощающий написание eBPF-программ. Он указывает, что эта функция — eBPF-программа, и ядро должно её обработать.</li><li>В теле функции вызывается пользовательская логика, например <strong><code>trace_connect()</code></strong>.</li></ol><hr><h3 id=syn-сегмент>SYN сегмент<a hidden class=anchor aria-hidden=true href=#syn-сегмент>#</a></h3><p>Когда локальное приложение пытается установить TCP-соединение, ядро вызывает <code>tcp_v4_connect()</code>. Наш eBPF-скрипт перехватывает этот вызов и запускает код из <code>trace_connect(sk)</code>, где <code>sk</code> — экземпляр структуры <code>sock</code>.</p><blockquote><p><a href=https://elixir.bootlin.com/linux/v6.1.80/source/include/net/sock.h#L354><code>sock</code></a> - структура ядра, представляет собой объект сетевого сокета, содержит: IP адреса, TCP порты, состояние соединения и т.д.</p></blockquote><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=k>static</span> <span class=kt>int</span> <span class=nf>trace_connect</span><span class=p>(</span><span class=k>const</span> <span class=k>struct</span> <span class=n>sock</span> <span class=o>*</span><span class=n>sk</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=n>u32</span> <span class=n>tgid</span> <span class=o>=</span> <span class=nf>bpf_get_current_pid_tgid</span><span class=p>()</span> <span class=o>&gt;&gt;</span> <span class=mi>32</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=k>struct</span> <span class=n>piddata</span> <span class=n>piddata</span> <span class=o>=</span> <span class=p>{};</span>
</span></span><span class=line><span class=cl>	<span class=n>piddata</span><span class=p>.</span><span class=n>ts</span> <span class=o>=</span> <span class=nf>bpf_ktime_get_ns</span><span class=p>();</span>
</span></span><span class=line><span class=cl>	<span class=n>piddata</span><span class=p>.</span><span class=n>tgid</span> <span class=o>=</span> <span class=n>tgid</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=nf>bpf_map_update_elem</span><span class=p>(</span><span class=o>&amp;</span><span class=n>start</span><span class=p>,</span> <span class=o>&amp;</span><span class=n>sk</span><span class=p>,</span> <span class=o>&amp;</span><span class=n>piddata</span><span class=p>,</span> <span class=mi>0</span><span class=p>);</span>
</span></span><span class=line><span class=cl>	<span class=k>return</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><ol><li><p><a href=https://docs.ebpf.io/linux/helper-function/bpf_get_current_pid_tgid/><strong><code>bpf_get_current_pid_tgid()</code></strong></a><br>Этот хелпер возвращает 64-битное значение, где:</p><ul><li>Младшие 32 бита — <strong>TID</strong> (Thread ID).</li><li>Старшие 32 бита — <strong>TGID</strong> (или проще говоря, PID процесса).<br>Конструкция <code>>> 32</code> извлекает старшие 32 бита, чтобы получить PID.</li></ul></li><li><p>создаем экземпляр структуры <code>piddata</code>:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=k>struct</span> <span class=n>piddata</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>u64</span> <span class=n>ts</span><span class=p>;</span>   <span class=c1>// Таймстамп события.
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>u32</span> <span class=n>tgid</span><span class=p>;</span> <span class=c1>// TGID (PID) процесса.
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>};</span>
</span></span></code></pre></div></li><li><p><strong><code>bpf_map_update_elem(&amp;start, &amp;sk, &amp;piddata, 0);</code></strong><br><a href=https://docs.ebpf.io/linux/helper-function/bpf_map_update_elem/>Хелпер</a> добавляет или обновляет элемент в карте (<strong>map</strong>) <code>start</code>, где ключом является <code>sk</code>, а значением — <code>piddata</code>.</p></li></ol><blockquote><p><strong>Map (карта)</strong> — <a href=https://docs.ebpf.io/linux/map-type/>специальная структура данных</a>, используемая eBPF-программами для хранения и обмена данными. Она работает по принципу словаря или хэш-таблицы: имеет ключи и значения, которые можно быстро находить, добавлять или обновлять.</p></blockquote><p>Определение карты <code>start</code>:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=k>struct</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=nf>__uint</span><span class=p>(</span><span class=n>type</span><span class=p>,</span> <span class=n>BPF_MAP_TYPE_HASH</span><span class=p>);</span>       <span class=c1>// Тип карты: хэш-таблица.
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=nf>__uint</span><span class=p>(</span><span class=n>max_entries</span><span class=p>,</span> <span class=mi>4096</span><span class=p>);</span>             <span class=c1>// Максимальное количество элементов.
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=nf>__type</span><span class=p>(</span><span class=n>key</span><span class=p>,</span> <span class=k>struct</span> <span class=n>sock</span> <span class=o>*</span><span class=p>);</span>            <span class=c1>// Тип ключа: указатель на структуру sock.
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=nf>__type</span><span class=p>(</span><span class=n>value</span><span class=p>,</span> <span class=k>struct</span> <span class=n>piddata</span><span class=p>);</span>         <span class=c1>// Тип значения: структура piddata.
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span> <span class=n>start</span> <span class=nf>SEC</span><span class=p>(</span><span class=s>&#34;.maps&#34;</span><span class=p>);</span>                          <span class=c1>// Имя карты.
</span></span></span></code></pre></div><p>Таким образом, при каждом вызове <code>tcp_v4_connect()</code> eBPF-программа сохраняет информацию о времени отправки SYN-сегмента и процессе, который инициировал соединение. Эти данные затем используются для сопоставления с полученными SYN-ACK-сегментами.</p><hr><h3 id=ответный-syn-ack>Ответный SYN-ACK<a hidden class=anchor aria-hidden=true href=#ответный-syn-ack>#</a></h3><p>Для обработки ответного SYN-ACK ядро вызывает функцию <code>tcp_rcv_state_process()</code>, мы перехватываем её и запускаем <code>handle_tcp_rcv_state_process()</code>:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-C data-lang=C><span class=line><span class=cl><span class=k>static</span> <span class=kt>int</span> <span class=nf>handle_tcp_rcv_state_process</span><span class=p>(</span><span class=kt>void</span> <span class=o>*</span><span class=n>ctx</span><span class=p>,</span> <span class=k>const</span> <span class=k>struct</span> <span class=n>sock</span> <span class=o>*</span><span class=n>sk</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=k>if</span> <span class=p>(</span><span class=nf>BPF_CORE_READ</span><span class=p>(</span><span class=n>sk</span><span class=p>,</span> <span class=n>__sk_common</span><span class=p>.</span><span class=n>skc_state</span><span class=p>)</span> <span class=o>!=</span> <span class=n>TCP_SYN_SENT</span><span class=p>)</span>
</span></span><span class=line><span class=cl>		<span class=k>return</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=k>struct</span> <span class=n>piddata</span> <span class=o>*</span><span class=n>piddatap</span><span class=p>;</span>
</span></span><span class=line><span class=cl>	<span class=n>piddatap</span> <span class=o>=</span> <span class=nf>bpf_map_lookup_elem</span><span class=p>(</span><span class=o>&amp;</span><span class=n>start</span><span class=p>,</span> <span class=o>&amp;</span><span class=n>sk</span><span class=p>);</span>
</span></span><span class=line><span class=cl>	<span class=k>if</span> <span class=p>(</span><span class=o>!</span><span class=n>piddatap</span><span class=p>)</span>
</span></span><span class=line><span class=cl>		<span class=k>return</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>	
</span></span><span class=line><span class=cl>	<span class=kt>int</span> <span class=n>af</span><span class=p>;</span>
</span></span><span class=line><span class=cl>	<span class=n>af</span> <span class=o>=</span> <span class=nf>BPF_CORE_READ</span><span class=p>(</span><span class=n>sk</span><span class=p>,</span> <span class=n>__sk_common</span><span class=p>.</span><span class=n>skc_family</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  	<span class=k>switch</span> <span class=p>(</span><span class=n>af</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  	<span class=k>case</span> <span class=nl>AF_INET</span><span class=p>:</span>
</span></span><span class=line><span class=cl>  	    <span class=k>return</span> <span class=nf>handle_ipv4</span><span class=p>(</span><span class=n>sk</span><span class=p>,</span> <span class=n>piddatap</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  	<span class=k>case</span> <span class=nl>AF_INET6</span><span class=p>:</span>
</span></span><span class=line><span class=cl>  	    <span class=k>return</span> <span class=nf>handle_ipv6</span><span class=p>(</span><span class=n>sk</span><span class=p>,</span> <span class=n>piddatap</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  	<span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  	<span class=k>return</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><ol><li>С помощью макроса <a href=https://docs.ebpf.io/ebpf-library/libbpf/ebpf/BPF_CORE_READ/><code>BPF_CORE_READ</code></a> читаем поле <a href=https://elixir.bootlin.com/linux/v6.1.80/source/include/net/sock.h#L129>__sk_common.skc_state</a> - интересует только состояние SYN-SENT.</li><li>Экзепляр сокета (<code>sk</code>) используется как ключ для поиска данных в карте <code>start</code>. Если данные отсутствуют, выходим из функции.</li><li>Определяется тип сокета (поле <a href=https://elixir.bootlin.com/linux/v6.1.80/source/include/net/sock.h#L128><code>__sk_common.skc_family</code></a>): <code>AF_UNIX</code>, <code>AF_INET</code>, <code>AF_INET6</code>, <code>AF_NETLINK</code>, ….</li><li>Для обработки IPv4 (<code>AF_INET</code>) и IPv6 (<code>AF_INET6</code>) используются <code>handle_ipv4()</code> и <code>handle_ipv6()</code> соответственно.</li></ol><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=k>static</span> <span class=kt>int</span> <span class=nf>handle_ipv4</span><span class=p>(</span><span class=k>const</span> <span class=k>struct</span> <span class=n>sock</span> <span class=o>*</span><span class=n>sk</span><span class=p>,</span> <span class=k>struct</span> <span class=n>piddata</span> <span class=o>*</span><span class=n>piddatap</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=k>struct</span> <span class=n>ipv4_event</span> <span class=n>event</span> <span class=o>=</span> <span class=p>{};</span>
</span></span><span class=line><span class=cl>	<span class=n>s64</span> <span class=n>delta</span><span class=p>;</span>
</span></span><span class=line><span class=cl>	<span class=n>u64</span> <span class=n>ts</span><span class=p>;</span>
</span></span><span class=line><span class=cl>	<span class=n>u64</span> <span class=n>delta_us</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=n>ts</span> <span class=o>=</span> <span class=nf>bpf_ktime_get_ns</span><span class=p>();</span> <span class=c1>// Получаем текущее время
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=n>delta</span> <span class=o>=</span> <span class=p>(</span><span class=n>s64</span><span class=p>)(</span><span class=n>ts</span> <span class=o>-</span> <span class=n>piddatap</span><span class=o>-&gt;</span><span class=n>ts</span><span class=p>);</span> <span class=c1>// Вычисляем дельту времени
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=k>if</span> <span class=p>(</span><span class=n>delta</span> <span class=o>&lt;</span> <span class=mi>0</span><span class=p>)</span>
</span></span><span class=line><span class=cl>		<span class=k>goto</span> <span class=n>cleanup</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=n>delta_us</span> <span class=o>=</span> <span class=n>delta</span> <span class=o>/</span> <span class=mi>1000U</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=c1>// Заполняем структуру event
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=n>event</span><span class=p>.</span><span class=n>laddr</span> <span class=o>=</span> <span class=nf>BPF_CORE_READ</span><span class=p>(</span><span class=n>sk</span><span class=p>,</span> <span class=n>__sk_common</span><span class=p>.</span><span class=n>skc_rcv_saddr</span><span class=p>);</span>
</span></span><span class=line><span class=cl>	<span class=n>event</span><span class=p>.</span><span class=n>daddr</span> <span class=o>=</span> <span class=nf>BPF_CORE_READ</span><span class=p>(</span><span class=n>sk</span><span class=p>,</span> <span class=n>__sk_common</span><span class=p>.</span><span class=n>skc_daddr</span><span class=p>);</span>
</span></span><span class=line><span class=cl>	<span class=n>event</span><span class=p>.</span><span class=n>main_port</span> <span class=o>=</span> <span class=nf>__builtin_bswap16</span><span class=p>(</span><span class=nf>BPF_CORE_READ</span><span class=p>(</span><span class=n>sk</span><span class=p>,</span> <span class=n>__sk_common</span><span class=p>.</span><span class=n>skc_dport</span><span class=p>));</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=c1>// Строим гистограмму из карты ipv4_connection_latency_seconds
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=nf>increment_exp2_histogram</span><span class=p>(</span><span class=o>&amp;</span><span class=n>ipv4_connection_latency_seconds</span><span class=p>,</span> <span class=n>event</span><span class=p>,</span> <span class=n>delta_us</span><span class=p>,</span> <span class=n>MAX_LATENCY_SLOT</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=nl>cleanup</span><span class=p>:</span>
</span></span><span class=line><span class=cl>	<span class=nf>bpf_map_delete_elem</span><span class=p>(</span><span class=o>&amp;</span><span class=n>start</span><span class=p>,</span> <span class=o>&amp;</span><span class=n>sk</span><span class=p>);</span> <span class=c1>// Удаляем данные из карты start
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=k>return</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><ul><li><p><code>increment_exp2_histogram()</code> - это функция самого <strong>ebpf_exporter</strong> для создания метрик гистограмного типа, подробнее в <a href="https://github.com/cloudflare/ebpf_exporter?tab=readme-ov-file#exp2zero-histograms">документации</a>.</p></li><li><p>определение карты <code>ipv4_connection_latency_seconds</code>:</p></li></ul><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=k>struct</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nf>__uint</span><span class=p>(</span><span class=n>type</span><span class=p>,</span> <span class=n>BPF_MAP_TYPE_HASH</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=nf>__uint</span><span class=p>(</span><span class=n>max_entries</span><span class=p>,</span> <span class=p>(</span><span class=n>MAX_LATENCY_SLOT</span> <span class=o>+</span> <span class=mi>1</span><span class=p>)</span> <span class=o>*</span> <span class=n>MAX_PORTS</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=nf>__type</span><span class=p>(</span><span class=n>key</span><span class=p>,</span> <span class=k>struct</span> <span class=n>ipv4_event</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=nf>__type</span><span class=p>(</span><span class=n>value</span><span class=p>,</span> <span class=n>u64</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>}</span> <span class=n>ipv4_connection_latency_seconds</span> <span class=nf>SEC</span><span class=p>(</span><span class=s>&#34;.maps&#34;</span><span class=p>);</span>
</span></span></code></pre></div><p>где ключом выступает структура <code>ipv4_event</code>:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=k>struct</span> <span class=n>ipv4_event</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>u32</span> <span class=n>laddr</span><span class=p>;</span> <span class=c1>// локальный IP-адрес
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>u32</span> <span class=n>daddr</span><span class=p>;</span> <span class=c1>// удаленный IP-адрес
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>u16</span> <span class=n>main_port</span><span class=p>;</span> <span class=c1>// порт удаленной машины
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>u64</span> <span class=n>bucket</span><span class=p>;</span> <span class=c1>// бакет для гистограммы
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>};</span>
</span></span></code></pre></div><p>А для записи длительности установки соединения подойдет беззнаковое <code>u64</code>.</p><hr><h3 id=создание-метрик>Создание метрик<a hidden class=anchor aria-hidden=true href=#создание-метрик>#</a></h3><p>На этом этапе все данные собраны. Теперь настроим <strong>ebpf_exporter</strong> для их правильной интерпретации и определим необходимые лейблы.</p><p>Создадим еще один файл с расширением <code>.yaml</code>:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-yaml data-lang=yaml><span class=line><span class=cl><span class=nt>metrics</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=nt>histograms</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=c># Название карты (map) с финальными данными и описание метрики</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span>- <span class=nt>name</span><span class=p>:</span><span class=w> </span><span class=l>ipv4_connection_latency_seconds</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>      </span><span class=nt>help</span><span class=p>:</span><span class=w> </span><span class=l>IPv4 Connection Latency histogram</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=c># Настройка гистограмы.</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=c># https://github.com/cloudflare/ebpf_exporter?tab=readme-ov-file#histogram</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>      </span><span class=nt>bucket_type</span><span class=p>:</span><span class=w> </span><span class=l>exp2</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>      </span><span class=nt>bucket_min</span><span class=p>:</span><span class=w> </span><span class=m>0</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>      </span><span class=nt>bucket_max</span><span class=p>:</span><span class=w> </span><span class=m>26</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>      </span><span class=nt>bucket_multiplier</span><span class=p>:</span><span class=w> </span><span class=m>0.000001</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=c># Определение лейблов, значения которых соответствуют подрядку полей структуры `ipv4_event`.</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=c># https://github.com/cloudflare/ebpf_exporter?tab=readme-ov-file#labels</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>      </span><span class=nt>labels</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span>- <span class=nt>name</span><span class=p>:</span><span class=w> </span><span class=l>laddr</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>          </span><span class=nt>size</span><span class=p>:</span><span class=w> </span><span class=m>4</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>          </span><span class=nt>decoders</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span>- <span class=nt>name</span><span class=p>:</span><span class=w> </span><span class=l>inet_ip</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span>- <span class=nt>name</span><span class=p>:</span><span class=w> </span><span class=l>daddr</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>          </span><span class=nt>size</span><span class=p>:</span><span class=w> </span><span class=m>4</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>          </span><span class=nt>decoders</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span>- <span class=nt>name</span><span class=p>:</span><span class=w> </span><span class=l>inet_ip</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span>- <span class=nt>name</span><span class=p>:</span><span class=w> </span><span class=l>main_port</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>          </span><span class=nt>size</span><span class=p>:</span><span class=w> </span><span class=m>8</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>          </span><span class=nt>decoders</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span>- <span class=nt>name</span><span class=p>:</span><span class=w> </span><span class=l>uint</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span>- <span class=nt>name</span><span class=p>:</span><span class=w> </span><span class=l>bucket</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>          </span><span class=nt>size</span><span class=p>:</span><span class=w> </span><span class=m>8</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>          </span><span class=nt>decoders</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span>- <span class=nt>name</span><span class=p>:</span><span class=w> </span><span class=l>uint</span><span class=w>
</span></span></span></code></pre></div><h3 id=итоги>Итоги<a hidden class=anchor aria-hidden=true href=#итоги>#</a></h3><p>Осталось запустить <strong>ebpf_exporter</strong>, настроить в <strong>Prometheus</strong> сбор метрик и построить необходимые графики.</p><p>Например так:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-promql data-lang=promql><span class=line><span class=cl><span class=kr>histogram_quantile</span><span class=o>(</span><span class=mf>0.90</span><span class=p>,</span><span class=w> </span><span class=kr>rate</span><span class=o>(</span><span class=nv>ebpf_exporter_ipv4_connection_latency_seconds_bucket</span><span class=p>{}[</span><span class=err>$__rate_interval</span><span class=p>]</span><span class=o>))</span><span class=w>
</span></span></span></code></pre></div><p>Теперь нам доступны метрики длительности установки соединений:
<img loading=lazy src=/images/rtt-tcpconnlat/connection-latency.png alt=connection-latency></p><p>И отвечать на вопрос &ldquo;в чем причина замедления: в приложении или инфраструктуре?&rdquo; становится немного проще.</p><blockquote><p>Полная версия исходного кода доступна на <a href=https://gist.github.com/alebsys/c318fc62cb7215e663616f04522d9cdc>GitHub</a>.</p></blockquote><hr><p>Удачи!</p></div><footer class=post-footer><ul class=post-tags><li><a href=https://alebedev.tech/tags/tcp/>Tcp</a></li><li><a href=https://alebedev.tech/tags/linux/>Linux</a></li><li><a href=https://alebedev.tech/tags/ebpf/>Ebpf</a></li></ul></footer><div id=disqus_thread></div><script>window.disqus_config=function(){},function(){if(["localhost","127.0.0.1"].indexOf(window.location.hostname)!=-1){document.getElementById("disqus_thread").innerHTML="Disqus comments not available by default when the website is previewed locally.";return}var t=document,e=t.createElement("script");e.async=!0,e.src="//https-alebsys-github-io.disqus.com/embed.js",e.setAttribute("data-timestamp",+new Date),(t.head||t.body).appendChild(e)}()</script><noscript>Please enable JavaScript to view the <a href=https://disqus.com/?ref_noscript>comments powered by Disqus.</a></noscript><a href=https://disqus.com class=dsq-brlink>comments powered by <span class=logo-disqus>Disqus</span></a></article></main><footer class=footer><span>&copy; 2025 <a href=https://alebedev.tech/>Performance Matters</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>